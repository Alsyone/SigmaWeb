<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Sigma TA Web v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background-color: #0b0b15;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            background-color: #1a1a2e;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.3s ease;
        }
        .header.collapsed {
            height: 0 !important;
            min-height: 0 !important;
            padding: 0 10px !important;
            opacity: 0;
            overflow: hidden;
        }
        .menu-row {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }
        .menu-row label {
            font-size: 12px;
            color: #aaa;
            min-width: 65px;
            white-space: nowrap;
        }
        .symbol-btn, .interval-btn {
            background-color: #2d2d44;
            color: #ccc;
            border: 1px solid #444;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            min-height: 28px;
            min-width: 42px;
            justify-content: center;
        }
        .symbol-btn.active, .interval-btn.active {
            background-color: #4a4a6a;
            color: white;
            border-color: #6a6a9a;
        }
        .header input, .header button {
            background-color: #2d2d44;
            color: white;
            border: 1px solid #444;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            min-height: 28px;
        }
        .header button {
            background-color: #4CAF50;
            cursor: pointer;
            font-weight: bold;
            min-width: 60px;
        }
        .header #resetBtn {
            background-color: #f44336;
        }
        .chart-title {
            background-color: #161625;
            padding: 8px 15px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .toggle-menu-btn {
            background: #2d2d44;
            border: 1px solid #444;
            color: #ccc;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
        }
        .toggle-menu-btn:hover {
            background: #3a3a5a;
        }
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            width: 100%;
        }
        .chart-container {
            flex: 1;
            position: relative;
            background-color: #0b0b15;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .status-bar {
            background-color: #1a1a2e;
            padding: 4px 10px;
            font-size: 11px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 5px;
        }
        @media (max-width: 600px) {
            .chart-container {
                height: calc(100% - 44px - 30px - 25px);
            }
        }
    </style>
</head>
<body>
    <div class="header" id="mainHeader">
        <div class="menu-row">
            <label>Symbol:</label>
            <div class="symbol-btn" data-symbol="BTCUSDT">‚Çø BTC</div>
            <div class="symbol-btn" data-symbol="ETHUSDT">Œû ETH</div>
            <div class="symbol-btn" data-symbol="BNBUSDT">üî∂ BNB</div>
            <div class="symbol-btn" data-symbol="ADAUSDT">üî∑ ADA</div>
            <div class="symbol-btn" data-symbol="SOLUSDT">‚óé SOL</div>
            <div class="symbol-btn" data-symbol="XRPUSDT">‚úï XRP</div>
            <div class="symbol-btn" data-symbol="DOGEUSDT">√ê DOGE</div>
            <div class="symbol-btn" data-symbol="DOTUSDT">‚Ä¢ DOT</div>
            <div class="symbol-btn" data-symbol="AVAXUSDT">‚ñ≤ AVAX</div>
            <div class="symbol-btn" data-symbol="SHIBUSDT">S SHIB</div>
        </div>
        <div class="menu-row">
            <label>Interval:</label>
            <div class="interval-btn" data-interval="1m">1m</div>
            <div class="interval-btn" data-interval="2m">2m</div>
            <div class="interval-btn" data-interval="3m">3m</div>
            <div class="interval-btn" data-interval="5m">5m</div>
            <div class="interval-btn" data-interval="10m">10m</div>
            <div class="interval-btn" data-interval="15m">15m</div>
            <div class="interval-btn" data-interval="20m">20m</div>
            <div class="interval-btn" data-interval="30m">30m</div>
            <div class="interval-btn" data-interval="1h">1h</div>
            <div class="interval-btn" data-interval="2h">2h</div>
            <div class="interval-btn" data-interval="3h">3h</div>
            <div class="interval-btn" data-interval="4h">4h</div>
            <div class="interval-btn" data-interval="6h">6h</div>
            <div class="interval-btn" data-interval="8h">8h</div>
            <div class="interval-btn" data-interval="12h">12h</div>
            <div class="interval-btn" data-interval="1d">1d</div>
            <div class="interval-btn" data-interval="2d">2d</div>
            <div class="interval-btn" data-interval="3d">3d</div>
            <div class="interval-btn" data-interval="1w">1w</div>
            <div class="interval-btn" data-interval="1M">1M</div>
            <div class="interval-btn" data-interval="2M">2M</div>
            <div class="interval-btn" data-interval="3M">3M</div>
            <div class="interval-btn" data-interval="4M">4M</div>
            <div class="interval-btn" data-interval="6M">6M</div>
            <div class="interval-btn" data-interval="1Y">1Y</div> <!-- –î–û–ë–ê–í–õ–ï–ù–û -->
        </div>
        <div class="menu-row">
            <label>A:</label>
            <input type="number" id="analysisLimit" value="10000" min="500" max="20000" step="500">
            <label>D:</label>
            <input type="number" id="displayLimit" value="24" min="10" max="1000" step="1">
            <label>EMA:</label>
            <input type="number" id="emaPeriod" value="48" min="10" max="500" step="1">
            <label>W:</label>
            <input type="number" id="derivWindow" value="2" min="2" max="20" step="1">
            <label>Upd:</label>
            <input type="number" id="updateInterval" value="5000" min="1000" max="300000" step="1000">
            <button id="applyBtn">Apply</button>
            <button id="resetBtn">Reset</button>
        </div>
    </div>
    <div class="chart-title" id="chartTitle">
        <span id="chartTitleText">‚Äî</span>
        <div class="toggle-menu-btn" id="toggleMenuBtn">‚â°</div>
    </div>
    <div class="container">
        <div class="chart-container">
            <canvas id="chartCanvas"></canvas>
        </div>
    </div>
    <div class="status-bar">
        <div id="lastUpdated">Last Updated: --:--:--</div>
        <div>Use Wheel to Zoom</div>
    </div>
    <script>
        const defaultConfig = {
            symbol: 'BTCUSDT',
            interval: '5m',
            analysisLimit: 10000,
            displayLimit: 24,
            emaPeriod: 48,
            derivWindow: 2,
            updateIntervalMs: 5000,
            markerOffsetPx: 10
        };

        const config = { ...defaultConfig };

        const precisionMap = {
            'BTCUSDT': 2, 'ETHUSDT': 2, 'BNBUSDT': 2, 'ADAUSDT': 3, 'SOLUSDT': 2,
            'XRPUSDT': 4, 'DOGEUSDT': 5, 'DOTUSDT': 3, 'AVAXUSDT': 2, 'SHIBUSDT': 8
        };

        let fullCandleData = [];
        let markers = [];
        let currentPrice = null;
        let lastUpdateTime = null;

        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        const chartTitleText = document.getElementById('chartTitleText');
        const mainHeader = document.getElementById('mainHeader');
        const toggleMenuBtn = document.getElementById('toggleMenuBtn');
        const symbolButtons = document.querySelectorAll('.symbol-btn');
        const intervalButtons = document.querySelectorAll('.interval-btn');
        const analysisLimitInput = document.getElementById('analysisLimit');
        const displayLimitInput = document.getElementById('displayLimit');
        const emaPeriodInput = document.getElementById('emaPeriod');
        const derivWindowInput = document.getElementById('derivWindow');
        const updateIntervalInput = document.getElementById('updateInterval');
        const applyBtn = document.getElementById('applyBtn');
        const resetBtn = document.getElementById('resetBtn');
        const lastUpdatedDiv = document.getElementById('lastUpdated');

        let menuCollapsed = false;

        toggleMenuBtn.addEventListener('click', () => {
            menuCollapsed = !menuCollapsed;
            mainHeader.classList.toggle('collapsed', menuCollapsed);
            toggleMenuBtn.textContent = menuCollapsed ? '‚â°' : '√ó';
            setTimeout(updateDisplay, 150);
        });

        const Database = {
            dbName: 'sigma_candles_v14',
            initDB: () => {
                if (!localStorage.getItem(this.dbName)) {
                    localStorage.setItem(this.dbName, JSON.stringify({}));
                }
            },
            save: (candles, symbol, interval) => {
                try {
                    const db = JSON.parse(localStorage.getItem(this.dbName)) || {};
                    const key = `${symbol}_${interval}`;
                    db[key] = candles.slice(-20000);
                    localStorage.setItem(this.dbName, JSON.stringify(db));
                } catch (e) {
                    console.error("DB save error:", e);
                }
            },
            load: (symbol, interval, limit) => {
                try {
                    const db = JSON.parse(localStorage.getItem(this.dbName)) || {};
                    const key = `${symbol}_${interval}`;
                    return db[key] ? db[key].slice(-limit) : [];
                } catch (e) {
                    console.error("DB load error:", e);
                    return [];
                }
            }
        };

        Database.initDB();

        const SettingsManager = {
            key: 'sigma_ta_settings_v14',
            load: () => {
                try {
                    return JSON.parse(localStorage.getItem(this.key)) || config;
                } catch {
                    return { ...config };
                }
            },
            save: () => {
                try {
                    localStorage.setItem(this.key, JSON.stringify(config));
                } catch (e) {
                    console.error("Settings save error:", e);
                }
            }
        };

        // === –ê–ì–†–ï–ì–ê–¶–ò–Ø ===
        function getBaseInterval(target) {
            if (['2m'].includes(target)) return '1m';
            if (['10m', '20m'].includes(target)) return '5m';
            if (['3h'].includes(target)) return '1h';
            if (['2d'].includes(target)) return '1d';
            if (['2M', '4M'].includes(target)) return '1M';
            if (['3M', '6M', '1Y'].includes(target)) return '1M';
            return target;
        }

        function aggregateCandles(candles, targetInterval) {
            const base = getBaseInterval(targetInterval);
            if (base === targetInterval || !candles.length) return candles;

            const simpleRules = {
                '2m': { step: 2 },
                '10m': { step: 2 },
                '20m': { step: 4 },
                '3h': { step: 3 },
                '2d': { step: 2 },
                '2M': { step: 2 },
                '4M': { step: 4 }
            };

            if (simpleRules[targetInterval]) {
                const { step } = simpleRules[targetInterval];
                const agg = [];
                for (let i = 0; i <= candles.length - step; i += step) {
                    const chunk = candles.slice(i, i + step);
                    const open = chunk[0].open;
                    const close = chunk[chunk.length - 1].close;
                    const high = Math.max(...chunk.map(c => c.high));
                    const low = Math.min(...chunk.map(c => c.low));
                    const time = chunk[0].time;
                    agg.push({ time, open, high, low, close });
                }
                return agg;
            }

            // –ö–∞–ª–µ–Ω–¥–∞—Ä–Ω—ã–µ: 3M, 6M, 1Y
            const groups = {};
            for (const c of candles) {
                const d = new Date(c.time);
                let key, groupTime;
                if (targetInterval === '3M') {
                    const q = Math.floor(d.getUTCMonth() / 3);
                    key = `${d.getUTCFullYear()}-Q${q}`;
                    groupTime = Date.UTC(d.getUTCFullYear(), q * 3, 1);
                } else if (targetInterval === '6M') {
                    const h = d.getUTCMonth() < 6 ? 0 : 1;
                    key = `${d.getUTCFullYear()}-H${h}`;
                    groupTime = Date.UTC(d.getUTCFullYear(), h * 6, 1);
                } else if (targetInterval === '1Y') {
                    const y = d.getUTCFullYear();
                    key = `Y${y}`;
                    groupTime = Date.UTC(y, 0, 1);
                } else {
                    continue;
                }
                if (!groups[key]) groups[key] = { time: groupTime, candles: [] };
                groups[key].candles.push(c);
            }

            const result = [];
            for (const g of Object.values(groups)) {
                const chunk = g.candles;
                if (!chunk.length) continue;
                const open = chunk[0].open;
                const close = chunk[chunk.length - 1].close;
                const high = Math.max(...chunk.map(c => c.high));
                const low = Math.min(...chunk.map(c => c.low));
                result.push({ time: g.time, open, high, low, close });
            }
            result.sort((a, b) => a.time - b.time);
            return result;
        }

        function init() {
            loadSettings();
            setupListeners();
            updateButtonStates();
            loadData();
            setInterval(loadData, config.updateIntervalMs);
            window.addEventListener('resize', () => requestAnimationFrame(updateDisplay));
            window.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            updateDisplay();
        }

        function loadSettings() {
            const saved = SettingsManager.load();
            Object.assign(config, saved);
            analysisLimitInput.value = config.analysisLimit;
            displayLimitInput.value = config.displayLimit;
            emaPeriodInput.value = config.emaPeriod;
            derivWindowInput.value = config.derivWindow;
            updateIntervalInput.value = config.updateIntervalMs;
        }

        function setupListeners() {
            symbolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    config.symbol = btn.dataset.symbol;
                    updateButtonStates();
                    applySettings();
                });
            });
            intervalButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    config.interval = btn.dataset.interval;
                    updateButtonStates();
                    applySettings();
                });
            });
            applyBtn.addEventListener('click', applySettings);
            resetBtn.addEventListener('click', resetSettings);
            [analysisLimitInput, displayLimitInput, emaPeriodInput, derivWindowInput, updateIntervalInput]
                .forEach(el => el.addEventListener('change', applySettings));
        }

        function resetSettings() {
            Object.assign(config, defaultConfig);
            analysisLimitInput.value = config.analysisLimit;
            displayLimitInput.value = config.displayLimit;
            emaPeriodInput.value = config.emaPeriod;
            derivWindowInput.value = config.derivWindow;
            updateIntervalInput.value = config.updateIntervalMs;
            SettingsManager.save();
            updateButtonStates();
            loadData();
        }

        function updateButtonStates() {
            symbolButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.symbol === config.symbol);
            });
            intervalButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.interval === config.interval);
            });
        }

        function applySettings() {
            config.analysisLimit = parseInt(analysisLimitInput.value);
            config.displayLimit = parseInt(displayLimitInput.value);
            config.emaPeriod = parseInt(emaPeriodInput.value);
            config.derivWindow = parseInt(derivWindowInput.value);
            config.updateIntervalMs = parseInt(updateIntervalInput.value);
            SettingsManager.save();
            document.title = `Sigma TA Web - ${config.symbol} (${config.interval})`;
            loadData();
        }

        function adjustDisplayLimit(delta) {
            let newVal = config.displayLimit + delta;
            newVal = Math.max(10, Math.min(1000, newVal));
            if (newVal !== config.displayLimit) {
                config.displayLimit = newVal;
                displayLimitInput.value = newVal;
                updateDisplay();
            }
        }

        function handleKeyDown(e) {
            if (e.key === '+' || e.key === '=' || e.key === 'Add') {
                adjustDisplayLimit(-5);
                e.preventDefault();
            } else if (e.key === '-' || e.key === '_' || e.key === 'Subtract') {
                adjustDisplayLimit(5);
                e.preventDefault();
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 10 : -10;
            adjustDisplayLimit(delta);
        }

        async function loadData() {
            try {
                await loadRealData();
            } catch (err) {
                console.warn("Real data failed:", err.message);
                const cached = Database.load(config.symbol, config.interval, config.analysisLimit);
                if (cached.length > 0) {
                    fullCandleData = cached;
                } else {
                    generateSimulatedData();
                }
                updateStatus();
            }
            analyzeData();
            updateDisplay();
            Database.save(fullCandleData, config.symbol, config.interval);
        }

        async function loadRealData() {
            const baseInt = getBaseInterval(config.interval);
            let limit = config.analysisLimit;

            const simpleRules = { '2m':2, '10m':2, '20m':4, '3h':3, '2d':2, '2M':2, '4M':4 };
            if (simpleRules[config.interval]) {
                limit = Math.min(1000, config.analysisLimit * simpleRules[config.interval]);
            } else if (['3M','6M','1Y'].includes(config.interval)) {
                limit = Math.min(1000, config.analysisLimit);
            }

            const url = `https://api.binance.com/api/v3/klines?symbol=${config.symbol}&interval=${baseInt}&limit=${limit}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const raw = await res.json();
            const baseCandles = raw.map(item => ({
                time: item[0],
                open: parseFloat(item[1]),
                high: parseFloat(item[2]),
                low: parseFloat(item[3]),
                close: parseFloat(item[4])
            }));
            fullCandleData = aggregateCandles(baseCandles, config.interval);
            updateStatus();
        }

        function generateSimulatedData() {
            const now = Date.now();
            const sec = getIntervalSeconds(config.interval);
            fullCandleData = [];
            let t = now - config.analysisLimit * sec * 1000;
            let price = 40000 + Math.random() * 20000;
            for (let i = 0; i < config.analysisLimit; i++) {
                const vol = 0.02;
                const chg = (Math.random() - 0.5) * vol * 2;
                const open = price;
                const close = open * (1 + chg);
                const high = Math.max(open, close) * (1 + Math.random() * 0.01);
                const low = Math.min(open, close) * (1 - Math.random() * 0.01);
                const prec = precisionMap[config.symbol] ?? 2;
                fullCandleData.push({
                    time: t,
                    open: parseFloat(open.toFixed(prec)),
                    high: parseFloat(high.toFixed(prec)),
                    low: parseFloat(low.toFixed(prec)),
                    close: parseFloat(close.toFixed(prec))
                });
                price = close;
                t += sec * 1000;
            }
            updateStatus();
        }

        function updateStatus() {
            if (!fullCandleData.length) return;
            currentPrice = fullCandleData[fullCandleData.length - 1].close;
            lastUpdateTime = new Date();
            const up = fullCandleData.length > 1 && currentPrice >= fullCandleData[fullCandleData.length - 2].close;
            const color = up ? '#26a69a' : '#ef5350';
            const prec = precisionMap[config.symbol] ?? 2;
            const formattedPrice = currentPrice.toLocaleString('en', {
                minimumFractionDigits: prec,
                maximumFractionDigits: prec
            });
            chartTitleText.innerHTML = `${config.symbol} (${config.interval}) &nbsp; <span style="color:${color}">$${formattedPrice}</span>`;
            lastUpdatedDiv.textContent = `Last Updated: ${formatTime(lastUpdateTime)}`;
        }

        function getIntervalSeconds(interval) {
            const map = {
                '1m':60, '2m':120, '3m':180, '5m':300, '10m':600, '15m':900, '20m':1200, '30m':1800,
                '1h':3600, '2h':7200, '3h':10800, '4h':14400, '6h':21600, '8h':28800, '12h':43200,
                '1d':86400, '2d':172800, '3d':259200, '1w':604800, '1M':2592000,
                '2M':5184000, '3M':7776000, '4M':10368000, '6M':15552000, '1Y':31536000
            };
            return map[interval] || 3600;
        }

        function formatTime(date) {
            return date.toTimeString().split(' ')[0];
        }

        function analyzeData() {
            if (fullCandleData.length < config.emaPeriod + 20) {
                markers = [];
                return;
            }
            const closes = fullCandleData.map(d => d.close);
            const ema = calculateEMA(closes, config.emaPeriod);
            const deriv = calculateDerivative(ema, config.derivWindow);
            markers = findExtremeMarkers(fullCandleData, ema, deriv);
        }

        function calculateEMA(prices, period) {
            const ema = [prices[0]];
            const alpha = 2 / (period + 1);
            for (let i = 1; i < prices.length; i++) {
                ema[i] = alpha * prices[i] + (1 - alpha) * ema[i-1];
            }
            return ema;
        }

        function calculateDerivative(vals, w) {
            const d = new Array(vals.length).fill(0);
            for (let i = w; i < vals.length; i++) {
                d[i] = vals[i] - vals[i - w];
            }
            return d;
        }

        function findExtremeMarkers(data, ema, deriv) {
            const start = config.emaPeriod + 10;
            const end = deriv.length - 5;
            if (end <= start) return [];
            const slice = deriv.slice(start, end);
            const mean = slice.reduce((a,b) => a + b, 0) / slice.length;
            const variance = slice.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / slice.length;
            const std = Math.sqrt(variance || 1);
            if (std === 0) return [];
            const z = deriv.map(v => (v - mean) / std);
            const res = [];
            for (let i = start; i < end; i++) {
                const zi = z[i];
                if (Math.abs(zi) < 1) continue;
                const d = data[i];
                let color, yPrice, isAbove;
                if (zi > 0) {
                    yPrice = d.high;
                    isAbove = true;
                    color = Math.abs(zi) >= 3 ? '#FF00FF' : Math.abs(zi) >= 2 ? '#FF0000' : '#FFFF00';
                } else {
                    yPrice = d.low;
                    isAbove = false;
                    color = Math.abs(zi) >= 3 ? '#00FFFF' : Math.abs(zi) >= 2 ? '#0000FF' : '#FFFFFF';
                }
                res.push({ time: d.time, price: yPrice, color, isAbove });
            }
            return res;
        }

        function updateDisplay() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            if (width > 0 && height > 0) {
                canvas.width = width;
                canvas.height = height;
                drawChart();
            }
        }

        function drawChart() {
            if (!fullCandleData.length) return;

            const extraCandles = 4;
            const extendedData = [...fullCandleData];
            const last = fullCandleData[fullCandleData.length - 1];
            const sec = getIntervalSeconds(config.interval);
            for (let i = 1; i <= extraCandles; i++) {
                extendedData.push({
                    time: last.time + i * sec * 1000,
                    open: last.close,
                    high: last.close,
                    low: last.close,
                    close: last.close
                });
            }

            const total = config.displayLimit + extraCandles;
            const displayData = extendedData.slice(-total).slice(0, -extraCandles);
            if (displayData.length === 0) return;

            const visibleTimes = new Set(displayData.map(d => d.time));
            const visibleMarkers = markers.filter(m => visibleTimes.has(m.time));

            const w = canvas.width;
            const h = canvas.height;
            const marginX = Math.max(50, Math.min(70, w * 0.1));
            const marginY = 40;
            const drawH = h - 2 * marginY;

            ctx.fillStyle = '#0b0b15';
            ctx.fillRect(0, 0, w, h);

            const times = displayData.map(d => d.time);
            const lows = displayData.map(d => d.low);
            const highs = displayData.map(d => d.high);
            const tMin = Math.min(...times);
            const tMax = Math.max(...times);
            const pMin = Math.min(...lows);
            const pMax = Math.max(...highs);
            const priceRange = pMax - pMin;
            const padding = priceRange * 0.05;
            const pMinAdj = pMin - padding;
            const pMaxAdj = pMax + padding;
            const priceRangeAdj = pMaxAdj - pMinAdj;
            const timeRange = tMax - tMin;

            drawPriceGrid(pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            if (currentPrice !== null) {
                drawCurrentPriceLine(currentPrice, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            }
            drawAdaptiveTimeGrid(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawCandles(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawMarkers(visibleMarkers, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawLegendTop(w, h, marginY);
        }

        function drawPriceGrid(pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const rawStep = priceRangeAdj / 6;
            const mag = Math.pow(10, Math.floor(Math.log10(rawStep)));
            const step = mag * Math.round(rawStep / mag) || rawStep;
            const start = step * Math.floor(pMinAdj / step);
            const n = Math.ceil((pMaxAdj - start) / step) + 1;
            for (let i = 0; i < n; i++) {
                const price = start + i * step;
                if (price < pMinAdj || price > pMaxAdj) continue;
                const y = marginY + (pMaxAdj - price) / priceRangeAdj * drawH;
                if (y < marginY || y > h - marginY) continue;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(marginX, y);
                ctx.lineTo(w - marginX, y);
                ctx.stroke();
                ctx.fillStyle = '#AAA';
                ctx.font = '10px Arial';
                const prec = precisionMap[config.symbol] ?? 2;
                const formatted = price.toLocaleString('en', {
                    minimumFractionDigits: Math.min(prec, 4),
                    maximumFractionDigits: Math.min(prec, 4)
                });
                ctx.fillText(formatted, w - marginX + (w > 500 ? 10 : 2), y + 4);
            }
        }

        function drawCurrentPriceLine(price, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const y = marginY + (pMaxAdj - price) / priceRangeAdj * drawH;
            if (y < marginY || y > h - marginY) return;
            let color = '#00FFFF';
            if (fullCandleData.length > 1) {
                const prev = fullCandleData[fullCandleData.length - 2].close;
                color = price >= prev ? '#26a69a' : '#ef5350';
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginX, y);
            ctx.lineTo(w - marginX, y);
            ctx.stroke();
            ctx.fillStyle = color;
            const prec = precisionMap[config.symbol] ?? 2;
            const formatted = price.toLocaleString('en', {
                minimumFractionDigits: prec,
                maximumFractionDigits: prec
            });
            ctx.font = 'bold 10px Arial';
            ctx.fillText(`$${formatted}`, w - marginX + (w > 500 ? 10 : 2), y - 2);
        }

        function drawAdaptiveTimeGrid(data, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const interval = config.interval;
            let majorStepMs = 0;
            let formatLabel = (ts) => '';

            if (['1m','2m','3m','5m','10m','20m'].includes(interval)) {
                majorStepMs = 3600 * 1000;
                formatLabel = (ts) => `${new Date(ts).getHours()}:00`;
            } else if (['15m','30m','1h','2h','3h','4h','6h','8h','12h'].includes(interval)) {
                majorStepMs = 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getDate()}`;
            } else if (['1d','2d','3d'].includes(interval)) {
                majorStepMs = 7 * 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getMonth()+1}/${new Date(ts).getDate()}`;
            } else if (interval === '1w') {
                majorStepMs = 30.44 * 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getMonth()+1}/${String(new Date(ts).getFullYear()).slice(-2)}`;
            } else if (['1M','2M','3M','4M','6M'].includes(interval)) {
                majorStepMs = 365.25 * 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getFullYear()}`;
            } else if (interval === '1Y') {
                // –ì–æ–¥–æ–≤–æ–π: –¥–µ–ª–µ–Ω–∏—è –∫–∞–∂–¥—ã–µ 4 –≥–æ–¥–∞, –Ω–∞—á–∏–Ω–∞—è —Å–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞ –≤–∏—Å–æ–∫–æ—Å–Ω—ã–º
                const startYear = new Date(tMin).getUTCFullYear();
                // –ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à–∏–π –≥–æ–¥ ‚â• startYear, —Å–ª–µ–¥—É—é—â–∏–π –∑–∞ –≤–∏—Å–æ–∫–æ—Å–Ω—ã–º
                let firstMarkYear = startYear;
                while (true) {
                    const prev = firstMarkYear - 1;
                    if ((prev % 4 === 0 && prev % 100 !== 0) || (prev % 400 === 0)) {
                        break;
                    }
                    firstMarkYear++;
                    if (firstMarkYear > startYear + 10) {
                        // fallback, –µ—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏
                        firstMarkYear = startYear + (4 - (startYear % 4));
                        break;
                    }
                }
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –ª–∏–Ω–∏–∏
                const years = [];
                for (let y = firstMarkYear; y <= new Date(tMin + timeRange).getUTCFullYear() + 4; y += 4) {
                    const ts = Date.UTC(y, 0, 1);
                    years.push(ts);
                }
                for (const ts of years) {
                    const x = marginX + (ts - tMin) / timeRange * (w - 2 * marginX);
                    if (x < marginX || x > w - marginX) continue;
                    ctx.strokeStyle = '#555777';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, marginY);
                    ctx.lineTo(x, h - marginY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#888CCC';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${new Date(ts).getUTCFullYear()}`, x, h - 12);
                }
                return;
            } else {
                majorStepMs = 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getDate()}`;
            }

            const firstTs = tMin;
            let startMajor = Math.floor(firstTs / majorStepMs) * majorStepMs;
            for (let t = startMajor; t <= tMin + timeRange + majorStepMs; t += majorStepMs) {
                if (t < tMin - majorStepMs || t > tMin + timeRange + majorStepMs) continue;
                const x = marginX + (t - tMin) / timeRange * (w - 2 * marginX);
                if (x < marginX || x > w - marginX) continue;
                ctx.strokeStyle = '#555777';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, marginY);
                ctx.lineTo(x, h - marginY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#888CCC';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(formatLabel(t), x, h - 12);
            }
        }

        function drawCandles(data, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const candleWidth = Math.max(1, (w - 2 * marginX) / data.length * 0.8);
            for (const d of data) {
                const x = marginX + (d.time - tMin) / timeRange * (w - 2 * marginX);
                const yOpen = marginY + (pMaxAdj - d.open) / priceRangeAdj * drawH;
                const yClose = marginY + (pMaxAdj - d.close) / priceRangeAdj * drawH;
                const yHigh = marginY + (pMaxAdj - d.high) / priceRangeAdj * drawH;
                const yLow = marginY + (pMaxAdj - d.low) / priceRangeAdj * drawH;
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, yHigh);
                ctx.lineTo(x, yLow);
                ctx.stroke();
                const isUp = d.close >= d.open;
                ctx.strokeStyle = isUp ? '#26a69a' : '#ef5350';
                ctx.lineWidth = Math.max(1.5, candleWidth);
                const yBody = Math.min(yOpen, yClose);
                const hBody = Math.abs(yClose - yOpen);
                if (hBody < 2) {
                    ctx.beginPath();
                    ctx.moveTo(x, yBody - 1);
                    ctx.lineTo(x, yBody + 1);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(x, yBody);
                    ctx.lineTo(x, yBody + hBody);
                    ctx.stroke();
                }
            }
        }

        function drawMarkers(markers, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            for (const m of markers) {
                const x = marginX + (m.time - tMin) / timeRange * (w - 2 * marginX);
                const yBase = marginY + (pMaxAdj - m.price) / priceRangeAdj * drawH;
                const y = m.isAbove ? yBase - config.markerOffsetPx : yBase + config.markerOffsetPx;
                ctx.fillStyle = m.color;
                ctx.beginPath();
                ctx.arc(x, y, w > 400 ? 3 : 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawLegendTop(w, h, topY) {
            if (w < 400) return;
            const items = [
                { color: '#FF00FF', text: 'Strong +' },
                { color: '#FF0000', text: 'Moderate +' },
                { color: '#FFFF00', text: 'Weak +' },
                { color: '#00FFFF', text: 'Strong ‚Äì' },
                { color: '#0000FF', text: 'Moderate ‚Äì' },
                { color: '#FFFFFF', text: 'Weak ‚Äì' }
            ];
            const totalWidth = items.reduce((sum, item) => sum + ctx.measureText(item.text).width + 30, 0);
            const startX = w / 2 - totalWidth / 2;
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            let xOffset = startX;
            for (let i = 0; i < items.length; i++) {
                ctx.fillStyle = items[i].color;
                ctx.beginPath();
                ctx.arc(xOffset + 6, topY + 10, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.fillText(items[i].text, xOffset + 16, topY + 14);
                xOffset += ctx.measureText(items[i].text).width + 22;
            }
        }

        window.onload = init;
    </script>
</body>
</html>

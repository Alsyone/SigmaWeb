<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sigma TA Web - Cryptocurrency Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background-color: #0b0b15;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            background-color: #1a1a2e;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .header label {
            font-size: 12px;
            color: #aaa;
        }
        .header select, .header input, .header button {
            background-color: #2d2d44;
            color: white;
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .header button {
            background-color: #4CAF50;
            cursor: pointer;
            font-weight: bold;
        }
        .header button:hover {
            background-color: #45a049;
        }
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .chart-container {
            flex: 1;
            position: relative;
            background-color: #0b0b15;
        }
        canvas {
            display: block;
        }
        .status-bar {
            background-color: #1a1a2e;
            padding: 5px 15px;
            font-size: 12px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <div class="header">
        <label>Symbol:</label>
        <select id="symbolSelect">
            <option value="BTCUSDT">BTCUSDT</option>
            <option value="ETHUSDT">ETHUSDT</option>
            <option value="BNBUSDT">BNBUSDT</option>
            <option value="ADAUSDT">ADAUSDT</option>
            <option value="SOLUSDT">SOLUSDT</option>
        </select>
        <label>Interval:</label>
        <select id="intervalSelect">
            <option value="1m">1m</option>
            <option value="5m">5m</option>
            <option value="15m">15m</option>
            <option value="30m">30m</option>
            <option value="1h" selected>1h</option>
            <option value="4h">4h</option>
            <option value="1d">1d</option>
        </select>
        <label>Analysis:</label>
        <input type="number" id="analysisLimit" value="10000" min="500" max="20000" step="500" style="width: 75px;">
        <label>Display:</label>
        <input type="number" id="displayLimit" value="500" min="10" max="1000" step="10" style="width: 65px;">
        <label>EMA Period:</label>
        <input type="number" id="emaPeriod" value="96" min="10" max="500" step="10" style="width: 55px;">
        <label>Deriv Win:</label>
        <input type="number" id="derivWindow" value="4" min="2" max="20" step="1" style="width: 45px;">
        <label>Update (ms):</label>
        <input type="number" id="updateInterval" value="5000" min="1000" max="300000" step="1000" style="width: 75px;">
        <button id="applyBtn">Apply</button>
    </div>
    <div class="container">
        <div class="chart-container">
            <canvas id="chartCanvas"></canvas>
        </div>
    </div>
    <div class="status-bar">
        <div id="currentPrice">Current Price: N/A</div>
        <div id="lastUpdated">Last Updated: --:--:--</div>
    </div>
    <script>
        const config = {
            symbol: 'BTCUSDT',
            interval: '1h',
            analysisLimit: 10000,
            displayLimit: 500,
            emaPeriod: 96,
            derivWindow: 4,
            updateIntervalMs: 5000,
            markerOffsetPx: 10
        };

        let fullCandleData = []; // полный набор для анализа
        let markers = [];
        let currentPrice = null;
        let lastUpdateTime = null;

        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');

        const symbolSelect = document.getElementById('symbolSelect');
        const intervalSelect = document.getElementById('intervalSelect');
        const analysisLimitInput = document.getElementById('analysisLimit');
        const displayLimitInput = document.getElementById('displayLimit');
        const emaPeriodInput = document.getElementById('emaPeriod');
        const derivWindowInput = document.getElementById('derivWindow');
        const updateIntervalInput = document.getElementById('updateInterval');
        const applyBtn = document.getElementById('applyBtn');
        const currentPriceDiv = document.getElementById('currentPrice');
        const lastUpdatedDiv = document.getElementById('lastUpdated');

        const Database = {
            dbName: 'sigma_candles_v2',
            initDB: () => {
                if (!localStorage.getItem(this.dbName)) {
                    localStorage.setItem(this.dbName, JSON.stringify({}));
                }
            },
            save: (candles, symbol, interval) => {
                try {
                    const db = JSON.parse(localStorage.getItem(this.dbName)) || {};
                    const key = `${symbol}_${interval}`;
                    db[key] = candles.slice(-20000); // keep up to 20k
                    localStorage.setItem(this.dbName, JSON.stringify(db));
                } catch (e) {
                    console.error("DB save error:", e);
                }
            },
            load: (symbol, interval, limit) => {
                try {
                    const db = JSON.parse(localStorage.getItem(this.dbName)) || {};
                    const key = `${symbol}_${interval}`;
                    return db[key] ? db[key].slice(-limit) : [];
                } catch (e) {
                    console.error("DB load error:", e);
                    return [];
                }
            }
        };

        Database.initDB();

        const SettingsManager = {
            key: 'sigma_ta_settings_v2',
            load: () => {
                try {
                    return JSON.parse(localStorage.getItem(this.key)) || config;
                } catch {
                    return {...config};
                }
            },
            save: () => {
                try {
                    localStorage.setItem(this.key, JSON.stringify(config));
                } catch (e) {
                    console.error("Settings save error:", e);
                }
            }
        };

        function init() {
            loadSettings();
            setupListeners();
            loadData();
            setInterval(loadData, config.updateIntervalMs);
            window.addEventListener('resize', updateDisplay);
            updateDisplay();
        }

        function loadSettings() {
            const saved = SettingsManager.load();
            Object.assign(config, saved);
            symbolSelect.value = config.symbol;
            intervalSelect.value = config.interval;
            analysisLimitInput.value = config.analysisLimit;
            displayLimitInput.value = config.displayLimit;
            emaPeriodInput.value = config.emaPeriod;
            derivWindowInput.value = config.derivWindow;
            updateIntervalInput.value = config.updateIntervalMs;
        }

        function setupListeners() {
            const inputs = [symbolSelect, intervalSelect, analysisLimitInput, displayLimitInput, emaPeriodInput, derivWindowInput, updateIntervalInput];
            applyBtn.addEventListener('click', applySettings);
            inputs.forEach(el => el.addEventListener('change', applySettings));
        }

        function applySettings() {
            config.symbol = symbolSelect.value;
            config.interval = intervalSelect.value;
            config.analysisLimit = parseInt(analysisLimitInput.value);
            config.displayLimit = parseInt(displayLimitInput.value);
            config.emaPeriod = parseInt(emaPeriodInput.value);
            config.derivWindow = parseInt(derivWindowInput.value);
            config.updateIntervalMs = parseInt(updateIntervalInput.value);
            SettingsManager.save();
            document.title = `Sigma TA Web - ${config.symbol} (${config.interval})`;
            loadData();
        }

        async function loadData() {
            try {
                await loadRealData();
            } catch (err) {
                console.warn("Real data failed:", err.message);
                const cached = Database.load(config.symbol, config.interval, config.analysisLimit);
                if (cached.length > 0) {
                    fullCandleData = cached;
                    console.log("Using cached data");
                } else {
                    generateSimulatedData();
                }
                updateStatus();
            }
            analyzeData();
            updateDisplay();
            Database.save(fullCandleData, config.symbol, config.interval);
        }

        async function loadRealData() {
            const url = `https://api.binance.com/api/v3/klines?symbol=${config.symbol}&interval=${config.interval}&limit=${config.analysisLimit}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const raw = await res.json();
            fullCandleData = raw.map(item => ({
                time: item[0],
                open: parseFloat(item[1]),
                high: parseFloat(item[2]),
                low: parseFloat(item[3]),
                close: parseFloat(item[4])
            }));
            updateStatus();
        }

        function generateSimulatedData() {
            const now = Date.now();
            const sec = getIntervalSeconds(config.interval);
            fullCandleData = [];
            let t = now - config.analysisLimit * sec * 1000;
            let price = 40000 + Math.random() * 20000;
            for (let i = 0; i < config.analysisLimit; i++) {
                const vol = 0.02;
                const chg = (Math.random() - 0.5) * vol * 2;
                const open = price;
                const close = open * (1 + chg);
                const high = Math.max(open, close) * (1 + Math.random() * 0.01);
                const low = Math.min(open, close) * (1 - Math.random() * 0.01);
                fullCandleData.push({
                    time: t,
                    open: parseFloat(open.toFixed(2)),
                    high: parseFloat(high.toFixed(2)),
                    low: parseFloat(low.toFixed(2)),
                    close: parseFloat(close.toFixed(2))
                });
                price = close;
                t += sec * 1000;
            }
            updateStatus();
        }

        function updateStatus() {
            currentPrice = fullCandleData[fullCandleData.length - 1].close;
            lastUpdateTime = new Date();
            currentPriceDiv.textContent = `Current Price: $${currentPrice.toLocaleString()}`;
            lastUpdatedDiv.textContent = `Last Updated: ${formatTime(lastUpdateTime)}`;
        }

        function getIntervalSeconds(interval) {
            const map = { '1m':60,'5m':300,'15m':900,'30m':1800,'1h':3600,'4h':14400,'1d':86400 };
            return map[interval] || 3600;
        }

        function formatTime(date) {
            return date.toTimeString().split(' ')[0];
        }

        function analyzeData() {
            if (fullCandleData.length < config.emaPeriod + 20) {
                markers = [];
                return;
            }
            const closes = fullCandleData.map(d => d.close);
            const ema = calculateEMA(closes, config.emaPeriod);
            const deriv = calculateDerivative(ema, config.derivWindow);
            markers = findExtremeMarkers(fullCandleData, ema, deriv);
        }

        function calculateEMA(prices, period) {
            const ema = [prices[0]];
            const alpha = 2 / (period + 1);
            for (let i = 1; i < prices.length; i++) {
                ema[i] = alpha * prices[i] + (1 - alpha) * ema[i-1];
            }
            return ema;
        }

        function calculateDerivative(vals, w) {
            const d = new Array(vals.length).fill(0);
            for (let i = w; i < vals.length; i++) {
                d[i] = vals[i] - vals[i - w];
            }
            return d;
        }

        function findExtremeMarkers(data, ema, deriv) {
            const start = config.emaPeriod + 10;
            const end = deriv.length - 5;
            if (end <= start) return [];
            const slice = deriv.slice(start, end);
            const mean = slice.reduce((a,b) => a + b, 0) / slice.length;
            const variance = slice.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / slice.length;
            const std = Math.sqrt(variance || 1);
            if (std === 0) return [];
            const z = deriv.map(v => (v - mean) / std);
            const res = [];
            for (let i = start; i < end; i++) {
                const zi = z[i];
                if (Math.abs(zi) < 1) continue;
                const d = data[i];
                let color, yPrice, isAbove;
                if (zi > 0) {
                    yPrice = d.high;
                    isAbove = true;
                    color = Math.abs(zi) >= 3 ? '#FF00FF' : Math.abs(zi) >= 2 ? '#FF0000' : '#FFFF00';
                } else {
                    yPrice = d.low;
                    isAbove = false;
                    color = Math.abs(zi) >= 3 ? '#00FFFF' : Math.abs(zi) >= 2 ? '#0000FF' : '#FFFFFF';
                }
                res.push({ time: d.time, price: yPrice, color, isAbove });
            }
            return res;
        }

        function updateDisplay() {
            const cont = canvas.parentElement;
            canvas.width = cont.clientWidth;
            canvas.height = cont.clientHeight;
            drawChart();
        }

        function drawChart() {
            if (!fullCandleData.length) return;

            const displayData = fullCandleData.slice(-config.displayLimit);
            const visibleTimes = new Set(displayData.map(d => d.time));
            const visibleMarkers = markers.filter(m => visibleTimes.has(m.time));

            const w = canvas.width;
            const h = canvas.height;
            const marginX = 70;
            const marginY = 50;
            const drawW = w - 2 * marginX;
            const drawH = h - 2 * marginY;

            ctx.fillStyle = '#0b0b15';
            ctx.fillRect(0, 0, w, h);

            if (displayData.length === 0) return;

            const times = displayData.map(d => d.time);
            const lows = displayData.map(d => d.low);
            const highs = displayData.map(d => d.high);
            const tMin = Math.min(...times);
            const tMax = Math.max(...times);
            const pMin = Math.min(...lows);
            const pMax = Math.max(...highs);
            const priceRange = pMax - pMin;
            const padding = priceRange * 0.05;
            const pMinAdj = pMin - padding;
            const pMaxAdj = pMax + padding;
            const priceRangeAdj = pMaxAdj - pMinAdj;
            const timeRange = tMax - tMin;

            // Сетка и цены справа
            drawPriceGrid(pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            if (currentPrice !== null) {
                drawCurrentPriceLine(currentPrice, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            }
            drawDailyBoundaries(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawCandles(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawMarkers(visibleMarkers, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawLegendLeft(w, h, marginY);
        }

        function drawPriceGrid(pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const rawStep = priceRangeAdj / 6;
            const mag = Math.pow(10, Math.floor(Math.log10(rawStep)));
            const step = mag * Math.round(rawStep / mag) || rawStep;
            const start = step * Math.floor(pMinAdj / step);
            const n = Math.ceil((pMaxAdj - start) / step) + 1;
            for (let i = 0; i < n; i++) {
                const price = start + i * step;
                if (price < pMinAdj || price > pMaxAdj) continue;
                const y = marginY + (pMaxAdj - price) / priceRangeAdj * drawH;
                if (y < marginY || y > h - marginY) continue;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(marginX, y);
                ctx.lineTo(w - marginX, y);
                ctx.stroke();
                ctx.fillStyle = '#AAA';
                ctx.font = '10px Arial';
                ctx.fillText(price.toLocaleString(), w - marginX + 10, y + 4);
            }
        }

        function drawCurrentPriceLine(price, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const y = marginY + (pMaxAdj - price) / priceRangeAdj * drawH;
            if (y < marginY || y > h - marginY) return;
            let color = '#00FFFF';
            if (fullCandleData.length > 1) {
                const prev = fullCandleData[fullCandleData.length - 2].close;
                color = price >= prev ? '#26a69a' : '#ef5350';
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginX, y);
            ctx.lineTo(w - marginX, y);
            ctx.stroke();
            ctx.fillStyle = color;
            ctx.font = 'bold 11px Arial';
            ctx.fillText(`$${price.toLocaleString()}`, w - marginX + 10, y - 2);
        }

        function drawDailyBoundaries(data, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const seen = new Set();
            for (const d of data) {
                const dt = new Date(d.time);
                const key = dt.toDateString();
                if (seen.has(key)) continue;
                seen.add(key);
                const dayStart = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate()).getTime();
                if (dayStart < tMin || dayStart > tMin + timeRange) continue;
                const x = marginX + (dayStart - tMin) / timeRange * (w - 2 * marginX);
                ctx.strokeStyle = '#555777';
                ctx.lineWidth = 1;
                ctx.setLineDash([5,5]);
                ctx.beginPath();
                ctx.moveTo(x, marginY);
                ctx.lineTo(x, h - marginY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#888CCC';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${dt.getMonth()+1}-${dt.getDate()}`, x, h - 15);
            }
        }

        function drawCandles(data, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const candleWidth = Math.max(1, (w - 2 * marginX) / data.length * 0.8);
            for (const d of data) {
                const x = marginX + (d.time - tMin) / timeRange * (w - 2 * marginX);
                const yOpen = marginY + (pMaxAdj - d.open) / priceRangeAdj * drawH;
                const yClose = marginY + (pMaxAdj - d.close) / priceRangeAdj * drawH;
                const yHigh = marginY + (pMaxAdj - d.high) / priceRangeAdj * drawH;
                const yLow = marginY + (pMaxAdj - d.low) / priceRangeAdj * drawH;
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, yHigh);
                ctx.lineTo(x, yLow);
                ctx.stroke();
                const isUp = d.close >= d.open;
                ctx.strokeStyle = isUp ? '#26a69a' : '#ef5350';
                ctx.lineWidth = Math.max(2, candleWidth);
                const yBody = Math.min(yOpen, yClose);
                const hBody = Math.abs(yClose - yOpen);
                if (hBody < 2) {
                    ctx.beginPath();
                    ctx.moveTo(x, yBody - 1);
                    ctx.lineTo(x, yBody + 1);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(x, yBody);
                    ctx.lineTo(x, yBody + hBody);
                    ctx.stroke();
                }
            }
        }

        function drawMarkers(markers, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            for (const m of markers) {
                const x = marginX + (m.time - tMin) / timeRange * (w - 2 * marginX);
                const yBase = marginY + (pMaxAdj - m.price) / priceRangeAdj * drawH;
                const y = m.isAbove ? yBase - config.markerOffsetPx : yBase + config.markerOffsetPx;
                ctx.fillStyle = m.color;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawLegendLeft(w, h, topY) {
            const items = [
                { color: '#FF00FF', text: 'Strong +' },
                { color: '#FF0000', text: 'Moderate +' },
                { color: '#FFFF00', text: 'Weak +' },
                { color: '#00FFFF', text: 'Strong –' },
                { color: '#0000FF', text: 'Moderate –' },
                { color: '#FFFFFF', text: 'Weak –' }
            ];
            const startX = 10;
            const itemH = 20;
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < items.length; i++) {
                const y = topY + i * itemH;
                ctx.fillStyle = items[i].color;
                ctx.beginPath();
                ctx.arc(startX + 6, y + 6, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.fillText(items[i].text, startX + 16, y + 10);
            }
        }

        window.onload = init;
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>SigmaTA Web v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background-color: #0b0b15;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .main-layout {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .header {
            background-color: #1a1a2e;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        .header.collapsed {
            height: 0 !important;
            min-height: 0 !important;
            padding: 0 10px !important;
            opacity: 0;
            overflow: hidden;
        }
        .footer {
            background-color: #1a1a2e;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.3s ease;
            z-index: 10;
        }
        .footer.collapsed {
            height: 0 !important;
            min-height: 0 !important;
            padding: 0 10px !important;
            opacity: 0;
            overflow: hidden;
        }
        .menu-row {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }
        .symbol-btn, .interval-btn {
            background-color: #2d2d44;
            color: #ccc;
            border: 1px solid #444;
            padding: 5px 6px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            min-height: 28px;
            min-width: 36px;
            justify-content: center;
        }
        .symbol-btn.active, .interval-btn.active {
            background-color: #4a4a6a;
            color: white;
            border-color: #6a6a9a;
        }
        .header input, .header button {
            background-color: #2d2d44;
            color: white;
            border: 1px solid #444;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            min-height: 28px;
        }
        .chart-title {
            background-color: #161625;
            padding: 8px 15px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            position: relative;
            z-index: 5;
        }
        .toggle-menu-btn {
            background: #2d2d44;
            border: 1px solid #444;
            color: #ccc;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
        }
        .toggle-menu-btn:hover {
            background: #3a3a5a;
        }
        .chart-wrapper {
			min-height: 0; /* –≤–∞–∂–Ω–æ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å–∂–∞—Ç–∏—è */
            position: relative;
            flex: 1;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .status-bar {
            background-color: #1a1a2e;
            padding: 4px 10px;
            font-size: 11px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 5px;
            z-index: 5;
        }
        .settings-icon {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #2d2d44;
            border: 1px solid #444;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            font-size: 14px;
            color: #ccc;
        }
        .settings-popup {
            position: absolute;
            top: 50px;
            left: 10px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            width: 220px;
            display: none;
            z-index: 30;
            color: white;
            font-size: 12px;
        }
        .settings-popup h3 {
            margin-bottom: 10px;
            font-size: 14px;
        }
        .popup-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }
        .popup-row label {
            width: 70px;
            color: #aaa;
        }
        .settings-popup input {
            background: #2d2d44;
            color: white;
            border: 1px solid #444;
            padding: 4px 6px;
            border-radius: 3px;
            width: 100px;
        }
        .popup-buttons {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }
        .popup-buttons button {
            flex: 1;
            padding: 4px;
            font-size: 11px;
            border-radius: 3px;
        }
        #popupApplyBtn { background-color: #4CAF50; color: white; }
        #popupResetBtn { background-color: #f44336; color: white; }
        #popupCloseBtn { background-color: #555; color: white; }
        }
    </style>
</head>
<body>
    <div class="main-layout">
        <div class="header" id="mainHeader">
            <div class="menu-row">
                <div class="symbol-btn" data-symbol="BTCUSDT">‚Çø BTC</div>
                <div class="symbol-btn" data-symbol="ETHUSDT">Œû ETH</div>
                <div class="symbol-btn" data-symbol="BNBUSDT">üî∂ BNB</div>
                <div class="symbol-btn" data-symbol="ADAUSDT">üî∑ ADA</div>
                <div class="symbol-btn" data-symbol="SOLUSDT">‚óé SOL</div>
                <div class="symbol-btn" data-symbol="XRPUSDT">‚úï XRP</div>
                <div class="symbol-btn" data-symbol="DOGEUSDT">√ê DOGE</div>
                <div class="symbol-btn" data-symbol="DOTUSDT">‚Ä¢ DOT</div>
                <div class="symbol-btn" data-symbol="AVAXUSDT">‚ñ≤ AVAX</div>
                <div class="symbol-btn" data-symbol="SHIBUSDT">S SHIB</div>
            </div>
        </div>

        <div class="chart-title" id="chartTitle">
            <span id="chartTitleText">‚Äî</span>
            <div class="toggle-menu-btn" id="toggleMenuBtn">‚â°</div>
        </div>

        <div class="chart-wrapper">
            <canvas id="chartCanvas"></canvas>
            <div class="settings-icon" id="settingsIcon">‚öôÔ∏è</div>
        </div>

        <div class="status-bar">
            <div id="lastUpdated">Last Updated: --:--:--</div>
            <div>Use Wheel to Zoom</div>
            <div class="toggle-menu-btn" id="toggleFooterBtn">‚â°</div>
        </div>

        <div class="footer" id="mainFooter">
            <div class="menu-row">
                <div class="interval-btn" data-interval="1m">1m</div>
                <div class="interval-btn" data-interval="2m">2m</div>
                <div class="interval-btn" data-interval="3m">3m</div>
                <div class="interval-btn" data-interval="5m">5m</div>
                <div class="interval-btn" data-interval="10m">10m</div>
                <div class="interval-btn" data-interval="15m">15m</div>
                <div class="interval-btn" data-interval="20m">20m</div>
                <div class="interval-btn" data-interval="30m">30m</div>
                <div class="interval-btn" data-interval="1h">1h</div>
                <div class="interval-btn" data-interval="2h">2h</div>
                <div class="interval-btn" data-interval="3h">3h</div>
                <div class="interval-btn" data-interval="4h">4h</div>
                <div class="interval-btn" data-interval="6h">6h</div>
                <div class="interval-btn" data-interval="8h">8h</div>
                <div class="interval-btn" data-interval="12h">12h</div>
                <div class="interval-btn" data-interval="1d">1d</div>
                <div class="interval-btn" data-interval="2d">2d</div>
                <div class="interval-btn" data-interval="3d">3d</div>
                <div class="interval-btn" data-interval="1w">1w</div>
                <div class="interval-btn" data-interval="1M">1M</div>
                <div class="interval-btn" data-interval="2M">2M</div>
                <div class="interval-btn" data-interval="3M">3M</div>
                <div class="interval-btn" data-interval="4M">4M</div>
                <div class="interval-btn" data-interval="6M">6M</div>
                <div class="interval-btn" data-interval="1Y">1Y</div>
            </div>
        </div>
    </div>

    <div class="settings-popup" id="settingsPopup">
        <h3>Settings</h3>
        <div class="popup-row">
            <label>A:</label>
            <input type="number" id="popupAnalysisLimit" value="10000" min="500" max="20000" step="500">
        </div>
        <div class="popup-row">
            <label>D:</label>
            <input type="number" id="popupDisplayLimit" value="24" min="10" max="1000" step="1">
        </div>
        <div class="popup-row">
            <label>EMA:</label>
            <input type="number" id="popupEmaPeriod" value="48" min="10" max="500" step="1">
        </div>
        <div class="popup-row">
            <label>W:</label>
            <input type="number" id="popupDerivWindow" value="2" min="2" max="20" step="1">
        </div>
        <div class="popup-row">
            <label>Upd (ms):</label>
            <input type="number" id="popupUpdateInterval" value="5000" min="1000" max="300000" step="1000">
        </div>
        <div class="popup-row">
            <label>Font Size:</label>
            <input type="number" id="popupFontSize" value="11" min="9" max="16" step="1">
        </div>
        <div class="popup-buttons">
            <button id="popupApplyBtn">Apply</button>
            <button id="popupResetBtn">Reset</button>
            <button id="popupCloseBtn">Close</button>
        </div>
    </div>

    <script>
        const defaultConfig = {
            symbol: 'BTCUSDT',
            interval: '5m',
            analysisLimit: 10000,
            displayLimit: 48,
            emaPeriod: 48,
            derivWindow: 2,
            updateIntervalMs: 5000,
            markerOffsetPx: 10,
            fontSize: 11
        };

        const config = { ...defaultConfig };

        const precisionMap = {
            'BTCUSDT': 2, 'ETHUSDT': 2, 'BNBUSDT': 2, 'ADAUSDT': 3, 'SOLUSDT': 2,
            'XRPUSDT': 4, 'DOGEUSDT': 5, 'DOTUSDT': 3, 'AVAXUSDT': 2, 'SHIBUSDT': 8
        };

        let fullCandleData = [];
        let markers = [];
        let currentPrice = null;
        let lastUpdateTime = null;

        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        const chartTitleText = document.getElementById('chartTitleText');
        const mainHeader = document.getElementById('mainHeader');
        const mainFooter = document.getElementById('mainFooter');
        const toggleMenuBtn = document.getElementById('toggleMenuBtn');
        const toggleFooterBtn = document.getElementById('toggleFooterBtn');
        const settingsIcon = document.getElementById('settingsIcon');
        const settingsPopup = document.getElementById('settingsPopup');

        const symbolButtons = document.querySelectorAll('.symbol-btn');
        const intervalButtons = document.querySelectorAll('.interval-btn');

        const popupAnalysisLimit = document.getElementById('popupAnalysisLimit');
        const popupDisplayLimit = document.getElementById('popupDisplayLimit');
        const popupEmaPeriod = document.getElementById('popupEmaPeriod');
        const popupDerivWindow = document.getElementById('popupDerivWindow');
        const popupUpdateInterval = document.getElementById('popupUpdateInterval');
        const popupFontSize = document.getElementById('popupFontSize');
        const popupApplyBtn = document.getElementById('popupApplyBtn');
        const popupResetBtn = document.getElementById('popupResetBtn');
        const popupCloseBtn = document.getElementById('popupCloseBtn');

        let menuCollapsed = false;
        let footerCollapsed = true;

        // –í–µ—Ä—Ö–Ω–µ–µ –º–µ–Ω—é
        toggleMenuBtn.addEventListener('click', () => {
            menuCollapsed = !menuCollapsed;
            mainHeader.classList.toggle('collapsed', menuCollapsed);
            toggleMenuBtn.textContent = menuCollapsed ? '‚â°' : '√ó';
            localStorage.setItem('sigma_menu_collapsed', String(menuCollapsed));
            setTimeout(updateDisplay, 150);
        });

        // –ù–∏–∂–Ω–µ–µ –º–µ–Ω—é
        toggleFooterBtn.addEventListener('click', () => {
            footerCollapsed = !footerCollapsed;
            mainFooter.classList.toggle('collapsed', footerCollapsed);
            toggleFooterBtn.textContent = footerCollapsed ? '‚â°' : '√ó';
            localStorage.setItem('sigma_footer_collapsed', String(footerCollapsed));
            setTimeout(updateDisplay, 150);
        });

        // –ü–æ–ø–∞–ø –Ω–∞—Å—Ç—Ä–æ–µ–∫
        settingsIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            settingsPopup.style.display = settingsPopup.style.display === 'block' ? 'none' : 'block';
        });

        document.addEventListener('click', (e) => {
            if (!settingsPopup.contains(e.target) && e.target !== settingsIcon) {
                settingsPopup.style.display = 'none';
            }
        });

        const Database = {
            dbName: 'sigma_candles_v16',
            initDB: () => {
                if (!localStorage.getItem(this.dbName)) {
                    localStorage.setItem(this.dbName, JSON.stringify({}));
                }
            },
            save: (candles, symbol, interval) => {
                try {
                    const db = JSON.parse(localStorage.getItem(this.dbName)) || {};
                    const key = `${symbol}_${interval}`;
                    db[key] = candles.slice(-20000);
                    localStorage.setItem(this.dbName, JSON.stringify(db));
                } catch (e) {
                    console.error("DB save error:", e);
                }
            },
            load: (symbol, interval, limit) => {
                try {
                    const db = JSON.parse(localStorage.getItem(this.dbName)) || {};
                    const key = `${symbol}_${interval}`;
                    return db[key] ? db[key].slice(-limit) : [];
                } catch (e) {
                    console.error("DB load error:", e);
                    return [];
                }
            }
        };

        const SettingsManager = {
            key: 'sigma_ta_settings_v16',
            load: () => {
                try {
                    return JSON.parse(localStorage.getItem(this.key)) || config;
                } catch {
                    return { ...config };
                }
            },
            save: () => {
                try {
                    localStorage.setItem(this.key, JSON.stringify(config));
                } catch (e) {
                    console.error("Settings save error:", e);
                }
            }
        };

        function getBaseInterval(target) {
            if (['2m'].includes(target)) return '1m';
            if (['10m', '20m'].includes(target)) return '5m';
            if (['3h'].includes(target)) return '1h';
            if (['2d'].includes(target)) return '1d';
            if (['2M', '4M'].includes(target)) return '1M';
            if (['3M', '6M', '1Y'].includes(target)) return '1M';
            return target;
        }

        function aggregateCandles(candles, targetInterval) {
            const base = getBaseInterval(targetInterval);
            if (base === targetInterval || !candles.length) return candles;

            const simpleRules = {
                '2m': { step: 2 },
                '10m': { step: 2 },
                '20m': { step: 4 },
                '3h': { step: 3 },
                '2d': { step: 2 },
                '2M': { step: 2 },
                '4M': { step: 4 }
            };

            if (simpleRules[targetInterval]) {
                const { step } = simpleRules[targetInterval];
                const agg = [];
                for (let i = 0; i <= candles.length - step; i += step) {
                    const chunk = candles.slice(i, i + step);
                    const open = chunk[0].open;
                    const close = chunk[chunk.length - 1].close;
                    const high = Math.max(...chunk.map(c => c.high));
                    const low = Math.min(...chunk.map(c => c.low));
                    const time = chunk[0].time;
                    agg.push({ time, open, high, low, close });
                }
                return agg;
            }

            const groups = {};
            for (const c of candles) {
                const d = new Date(c.time);
                let key, groupTime;
                if (targetInterval === '3M') {
                    const q = Math.floor(d.getUTCMonth() / 3);
                    key = `${d.getUTCFullYear()}-Q${q}`;
                    groupTime = Date.UTC(d.getUTCFullYear(), q * 3, 1);
                } else if (targetInterval === '6M') {
                    const h = d.getUTCMonth() < 6 ? 0 : 1;
                    key = `${d.getUTCFullYear()}-H${h}`;
                    groupTime = Date.UTC(d.getUTCFullYear(), h * 6, 1);
                } else if (targetInterval === '1Y') {
                    const y = d.getUTCFullYear();
                    key = `Y${y}`;
                    groupTime = Date.UTC(y, 0, 1);
                } else {
                    continue;
                }
                if (!groups[key]) groups[key] = { time: groupTime, candles: [] };
                groups[key].candles.push(c);
            }

            const result = [];
            for (const g of Object.values(groups)) {
                const chunk = g.candles;
                if (!chunk.length) continue;
                const open = chunk[0].open;
                const close = chunk[chunk.length - 1].close;
                const high = Math.max(...chunk.map(c => c.high));
                const low = Math.min(...chunk.map(c => c.low));
                result.push({ time: g.time, open, high, low, close });
            }
            result.sort((a, b) => a.time - b.time);
            return result;
        }

        function init() {
            loadSettings();
            setupListeners();
            updateButtonStates();

            // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –º–µ–Ω—é
            const menuState = localStorage.getItem('sigma_menu_collapsed');
            if (menuState === 'true' || menuState === null) {
                menuCollapsed = true;
                mainHeader.classList.add('collapsed');
                toggleMenuBtn.textContent = '‚â°';
            } else {
                menuCollapsed = false;
                mainHeader.classList.remove('collapsed');
                toggleMenuBtn.textContent = '√ó';
            }

            const footerState = localStorage.getItem('sigma_footer_collapsed');
            if (footerState === 'true' || footerState === null) {
                footerCollapsed = true;
                mainFooter.classList.add('collapsed');
                toggleFooterBtn.textContent = '‚â°';
            } else {
                footerCollapsed = false;
                mainFooter.classList.remove('collapsed');
                toggleFooterBtn.textContent = '√ó';
            }

            loadData();
            setInterval(loadData, config.updateIntervalMs);
            window.addEventListener('resize', () => requestAnimationFrame(updateDisplay));
            window.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            updateDisplay();
        }

        function loadSettings() {
            const saved = SettingsManager.load();
            Object.assign(config, saved);
            loadSettingsIntoPopup();
        }

        function loadSettingsIntoPopup() {
            popupAnalysisLimit.value = config.analysisLimit;
            popupDisplayLimit.value = config.displayLimit;
            popupEmaPeriod.value = config.emaPeriod;
            popupDerivWindow.value = config.derivWindow;
            popupUpdateInterval.value = config.updateIntervalMs;
            popupFontSize.value = config.fontSize || 11;
        }

        function setupListeners() {
            symbolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    config.symbol = btn.dataset.symbol;
                    updateButtonStates();
                    applySettings();
                });
            });
            intervalButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    config.interval = btn.dataset.interval;
                    updateButtonStates();
                    applySettings();
                });
            });

            popupApplyBtn.addEventListener('click', () => {
                config.analysisLimit = parseInt(popupAnalysisLimit.value);
                config.displayLimit = parseInt(popupDisplayLimit.value);
                config.emaPeriod = parseInt(popupEmaPeriod.value);
                config.derivWindow = parseInt(popupDerivWindow.value);
                config.updateIntervalMs = parseInt(popupUpdateInterval.value);
                config.fontSize = parseInt(popupFontSize.value);
                SettingsManager.save();
                loadData();
                settingsPopup.style.display = 'none';
            });

            popupResetBtn.addEventListener('click', () => {
                Object.assign(config, defaultConfig);
                loadSettingsIntoPopup();
                SettingsManager.save();
                loadData();
                settingsPopup.style.display = 'none';
            });

            popupCloseBtn.addEventListener('click', () => {
                settingsPopup.style.display = 'none';
            });
        }

        function updateButtonStates() {
            symbolButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.symbol === config.symbol);
            });
            intervalButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.interval === config.interval);
            });
        }

        function applySettings() {
            SettingsManager.save();
            document.title = `Sigma TA Web - ${config.symbol} (${config.interval})`;
            loadData();
        }

        function adjustDisplayLimit(delta) {
            let newVal = config.displayLimit + delta;
            newVal = Math.max(10, Math.min(1000, newVal));
            if (newVal !== config.displayLimit) {
                config.displayLimit = newVal;
                SettingsManager.save();
                updateDisplay();
            }
        }

        function handleKeyDown(e) {
            if (e.key === '+' || e.key === '=' || e.key === 'Add') {
                adjustDisplayLimit(-5);
                e.preventDefault();
            } else if (e.key === '-' || e.key === '_' || e.key === 'Subtract') {
                adjustDisplayLimit(5);
                e.preventDefault();
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 10 : -10;
            adjustDisplayLimit(delta);
        }

        async function loadData() {
            try {
                await loadRealData();
            } catch (err) {
                console.warn("Real data failed:", err.message);
                const cached = Database.load(config.symbol, config.interval, config.analysisLimit);
                if (cached.length > 0) {
                    fullCandleData = cached;
                } else {
                    generateSimulatedData();
                }
                updateStatus();
            }
            analyzeData();
            updateDisplay();
            Database.save(fullCandleData, config.symbol, config.interval);
        }

        async function loadRealData() {
            const baseInt = getBaseInterval(config.interval);
            let limit = config.analysisLimit;

            const simpleRules = { '2m':2, '10m':2, '20m':4, '3h':3, '2d':2, '2M':2, '4M':4 };
            if (simpleRules[config.interval]) {
                limit = Math.min(1000, config.analysisLimit * simpleRules[config.interval]);
            } else if (['3M','6M','1Y'].includes(config.interval)) {
                limit = Math.min(1000, config.analysisLimit);
            }

            const url = `https://api.binance.com/api/v3/klines?symbol=${config.symbol}&interval=${baseInt}&limit=${limit}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const raw = await res.json();
            const baseCandles = raw.map(item => ({
                time: item[0],
                open: parseFloat(item[1]),
                high: parseFloat(item[2]),
                low: parseFloat(item[3]),
                close: parseFloat(item[4])
            }));
            fullCandleData = aggregateCandles(baseCandles, config.interval);
            updateStatus();
        }

        function generateSimulatedData() {
            const now = Date.now();
            const sec = getIntervalSeconds(config.interval);
            fullCandleData = [];
            let t = now - config.analysisLimit * sec * 1000;
            let price = 40000 + Math.random() * 20000;
            for (let i = 0; i < config.analysisLimit; i++) {
                const vol = 0.02;
                const chg = (Math.random() - 0.5) * vol * 2;
                const open = price;
                const close = open * (1 + chg);
                const high = Math.max(open, close) * (1 + Math.random() * 0.01);
                const low = Math.min(open, close) * (1 - Math.random() * 0.01);
                const prec = precisionMap[config.symbol] ?? 2;
                fullCandleData.push({
                    time: t,
                    open: parseFloat(open.toFixed(prec)),
                    high: parseFloat(high.toFixed(prec)),
                    low: parseFloat(low.toFixed(prec)),
                    close: parseFloat(close.toFixed(prec))
                });
                price = close;
                t += sec * 1000;
            }
            updateStatus();
        }

        function updateStatus() {
            if (!fullCandleData.length) return;
            currentPrice = fullCandleData[fullCandleData.length - 1].close;
            lastUpdateTime = new Date();
            const up = fullCandleData.length > 1 && currentPrice >= fullCandleData[fullCandleData.length - 2].close;
            const color = up ? '#008000' : '#800000';
            const prec = precisionMap[config.symbol] ?? 2;
            const formattedPrice = currentPrice.toLocaleString('en', {
                minimumFractionDigits: prec,
                maximumFractionDigits: prec
            });
            chartTitleText.innerHTML = `${config.symbol} (${config.interval}) &nbsp; <span style="color:${color}">$${formattedPrice}</span>`;
            document.getElementById('lastUpdated').textContent = `Last Updated: ${formatTime(lastUpdateTime)}`;
        }

        function getIntervalSeconds(interval) {
            const map = {
                '1m':60, '2m':120, '3m':180, '5m':300, '10m':600, '15m':900, '20m':1200, '30m':1800,
                '1h':3600, '2h':7200, '3h':10800, '4h':14400, '6h':21600, '8h':28800, '12h':43200,
                '1d':86400, '2d':172800, '3d':259200, '1w':604800, '1M':2592000,
                '2M':5184000, '3M':7776000, '4M':10368000, '6M':15552000, '1Y':31536000
            };
            return map[interval] || 3600;
        }

        function formatTime(date) {
            return date.toTimeString().split(' ')[0];
        }

        function analyzeData() {
            if (fullCandleData.length < config.emaPeriod + 20) {
                markers = [];
                return;
            }
            const closes = fullCandleData.map(d => d.close);
            const ema = calculateEMA(closes, config.emaPeriod);
            const deriv = calculateDerivative(ema, config.derivWindow);
            markers = findExtremeMarkers(fullCandleData, ema, deriv);
        }

        function calculateEMA(prices, period) {
            const ema = [prices[0]];
            const alpha = 2 / (period + 1);
            for (let i = 1; i < prices.length; i++) {
                ema[i] = alpha * prices[i] + (1 - alpha) * ema[i-1];
            }
            return ema;
        }

        function calculateDerivative(vals, w) {
            const d = new Array(vals.length).fill(0);
            for (let i = w; i < vals.length; i++) {
                d[i] = vals[i] - vals[i - w];
            }
            return d;
        }

        function findExtremeMarkers(data, ema, deriv) {
            const start = config.emaPeriod + 10;
            const end = deriv.length - 5;
            if (end <= start) return [];
            const slice = deriv.slice(start, end);
            const mean = slice.reduce((a,b) => a + b, 0) / slice.length;
            const variance = slice.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / slice.length;
            const std = Math.sqrt(variance || 1);
            if (std === 0) return [];
            const z = deriv.map(v => (v - mean) / std);
            const res = [];
            for (let i = start; i < end; i++) {
                const zi = z[i];
                if (Math.abs(zi) < 1) continue;
                const d = data[i];
                let color, yPrice, isAbove;
                if (zi > 0) {
                    yPrice = d.high;
                    isAbove = true;
                    color = Math.abs(zi) >= 3 ? '#FF00FF' : Math.abs(zi) >= 2 ? '#FF0000' : '#FFFF00';
                } else {
                    yPrice = d.low;
                    isAbove = false;
                    color = Math.abs(zi) >= 3 ? '#00FFFF' : Math.abs(zi) >= 2 ? '#0000FF' : '#FFFFFF';
                }
                res.push({ time: d.time, price: yPrice, color, isAbove });
            }
            return res;
        }

        function updateDisplay() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            if (width > 0 && height > 0) {
                canvas.width = width;
                canvas.height = height;
                drawChart();
            }
        }

        function drawChart() {
            if (!fullCandleData.length) return;

            const displayData = fullCandleData.slice(-config.displayLimit);
            if (displayData.length === 0) return;

            const futureCandles = 5;
            const intervalSec = getIntervalSeconds(config.interval);
            const intervalMs = intervalSec * 1000;
            const lastTime = displayData[displayData.length - 1].time;

            const tMin = displayData[0].time;
            const tMax = lastTime + futureCandles * intervalMs;
            const timeRange = tMax - tMin;

            const visibleTimes = new Set(displayData.map(d => d.time));
            const visibleMarkers = markers.filter(m => visibleTimes.has(m.time));

            const w = canvas.width;
            const h = canvas.height;
            const marginX = Math.max(50, Math.min(70, w * 0.1));
            const marginY = 40;
            const drawH = h - 2 * marginY;

            ctx.fillStyle = '#0b0b15';
            ctx.fillRect(0, 0, w, h);

            const lows = displayData.map(d => d.low);
            const highs = displayData.map(d => d.high);
            const pMin = Math.min(...lows);
            const pMax = Math.max(...highs);
            const priceRange = pMax - pMin;
            const padding = priceRange * 0.05;
            const pMinAdj = pMin - padding;
            const pMaxAdj = pMax + padding;
            const priceRangeAdj = pMaxAdj - pMinAdj;

            drawPriceGrid(pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            if (currentPrice !== null) {
                drawCurrentPriceLine(currentPrice, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            }
            drawAdaptiveTimeGrid(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawCandles(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawMarkers(visibleMarkers, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawLegendTop(w, h, marginY);
        }

        function drawPriceGrid(pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const rawStep = priceRangeAdj / 6;
            const mag = Math.pow(10, Math.floor(Math.log10(rawStep)));
            const step = mag * Math.round(rawStep / mag) || rawStep;
            const start = step * Math.floor(pMinAdj / step);
            const n = Math.ceil((pMaxAdj - start) / step) + 1;
            for (let i = 0; i < n; i++) {
                const price = start + i * step;
                if (price < pMinAdj || price > pMaxAdj) continue;
                const y = marginY + (pMaxAdj - price) / priceRangeAdj * drawH;
                if (y < marginY || y > h - marginY) continue;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(marginX, y);
                ctx.lineTo(w - marginX, y);
                ctx.stroke();
                ctx.fillStyle = '#AAA';
                ctx.font = `${config.fontSize || 11}px Arial`;
                const prec = precisionMap[config.symbol] ?? 2;
                const formatted = price.toLocaleString('en', {
                    minimumFractionDigits: Math.min(prec, 4),
                    maximumFractionDigits: Math.min(prec, 4)
                });
                ctx.fillText(formatted, w - marginX + (w > 500 ? 10 : 2), y + 4);
            }
        }

        function drawCurrentPriceLine(price, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const y = marginY + (pMaxAdj - price) / priceRangeAdj * drawH;
            if (y < marginY || y > h - marginY) return;
            let color = '#00FFFF';
            if (fullCandleData.length > 1) {
                const prev = fullCandleData[fullCandleData.length - 2].close;
                color = price >= prev ? '#00FF00' : '#FF0000';
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginX, y);
            ctx.lineTo(w - marginX, y);
            ctx.stroke();
            ctx.fillStyle = color;
            const prec = precisionMap[config.symbol] ?? 2;
            const formatted = price.toLocaleString('en', {
                minimumFractionDigits: prec,
                maximumFractionDigits: prec
            });
            ctx.font = `bold ${config.fontSize || 11}px Arial`;
            ctx.fillText(`${formatted}`, w - marginX + (w > 500 ? 10 : 2), y - 2);
        }

        function drawAdaptiveTimeGrid(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const interval = config.interval;
            let majorStepMs = 0;
            let formatLabel = (ts) => '';

            if (['1m','2m','3m','5m','10m','20m'].includes(interval)) {
                majorStepMs = 3600 * 1000;
                formatLabel = (ts) => `${new Date(ts).getHours()}:00`;
            } else if (['15m','30m','1h','2h','3h','4h','6h','8h','12h'].includes(interval)) {
                majorStepMs = 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getDate()}`;
            } else if (['1d','2d','3d'].includes(interval)) {
                majorStepMs = 7 * 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getMonth()+1}/${new Date(ts).getDate()}`;
            } else if (interval === '1w') {
                majorStepMs = 30.44 * 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getMonth()+1}/${String(new Date(ts).getFullYear()).slice(-2)}`;
            } else if (['1M','2M','3M','4M','6M'].includes(interval)) {
                majorStepMs = 365.25 * 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getFullYear()}`;
            } else if (interval === '1Y') {
                const startYear = new Date(tMin).getUTCFullYear();
                let firstMarkYear = startYear;
                while (true) {
                    const prev = firstMarkYear - 1;
                    if ((prev % 4 === 0 && prev % 100 !== 0) || (prev % 400 === 0)) {
                        break;
                    }
                    firstMarkYear++;
                    if (firstMarkYear > startYear + 10) {
                        firstMarkYear = startYear + (4 - (startYear % 4));
                        break;
                    }
                }
                const years = [];
                for (let y = firstMarkYear; y <= new Date(tMin + timeRange).getUTCFullYear() + 4; y += 4) {
                    const ts = Date.UTC(y, 0, 1);
                    years.push(ts);
                }
                for (const ts of years) {
                    const x = marginX + (ts - tMin) / timeRange * (w - 2 * marginX);
                    if (x < marginX || x > w - marginX) continue;
                    ctx.strokeStyle = '#555777';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, marginY);
                    ctx.lineTo(x, h - marginY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#888CCC';
                    ctx.font = `${config.fontSize || 11}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`${new Date(ts).getUTCFullYear()}`, x, h - 12);
                }
                return;
            } else {
                majorStepMs = 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getDate()}`;
            }

            const firstTs = tMin;
            let startMajor = Math.floor(firstTs / majorStepMs) * majorStepMs;
            for (let t = startMajor; t <= tMin + timeRange + majorStepMs; t += majorStepMs) {
                if (t < tMin - majorStepMs || t > tMin + timeRange + majorStepMs) continue;
                const x = marginX + (t - tMin) / timeRange * (w - 2 * marginX);
                if (x < marginX || x > w - marginX) continue;
                ctx.strokeStyle = '#555777';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, marginY);
                ctx.lineTo(x, h - marginY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#888CCC';
                ctx.font = `${config.fontSize || 11}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(formatLabel(t), x, h - 12);
            }
        }

        function drawCandles(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const candleWidth = Math.max(1, (w - 2 * marginX) / displayData.length * 0.7);
            for (const d of displayData) {
                const x = marginX + (d.time - tMin) / timeRange * (w - 2 * marginX);
                const yOpen = marginY + (pMaxAdj - d.open) / priceRangeAdj * drawH;
                const yClose = marginY + (pMaxAdj - d.close) / priceRangeAdj * drawH;
                const yHigh = marginY + (pMaxAdj - d.high) / priceRangeAdj * drawH;
                const yLow = marginY + (pMaxAdj - d.low) / priceRangeAdj * drawH;
                // ctx.strokeStyle = '#666';
				const isUp = d.close >= d.open;
                ctx.strokeStyle = isUp ? '#008000' : '#800000	';

                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, yHigh);
                ctx.lineTo(x, yLow);
                ctx.stroke();
                // const isUp = d.close >= d.open;
                // ctx.strokeStyle = isUp ? '#26a69a' : '#ef5350';
                ctx.lineWidth = Math.max(1.5, candleWidth);
                const yBody = Math.min(yOpen, yClose);
                const hBody = Math.abs(yClose - yOpen);
                if (hBody < 2) {
                    ctx.beginPath();
                    ctx.moveTo(x, yBody - 1);
                    ctx.lineTo(x, yBody + 1);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(x, yBody);
                    ctx.lineTo(x, yBody + hBody);
                    ctx.stroke();
                }
            }
        }

        function drawMarkers(markers, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            for (const m of markers) {
                const x = marginX + (m.time - tMin) / timeRange * (w - 2 * marginX);
                const yBase = marginY + (pMaxAdj - m.price) / priceRangeAdj * drawH;
                const y = m.isAbove ? yBase - config.markerOffsetPx : yBase + config.markerOffsetPx;
                ctx.fillStyle = m.color;
                ctx.beginPath();
                ctx.arc(x, y, w > 400 ? 3 : 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawLegendTop(w, h, topY) {
            if (w < 400) return;
            const items = [
                { color: '#FF00FF', text: 'Strong +' },
                { color: '#FF0000', text: 'Moderate +' },
                { color: '#FFFF00', text: 'Weak +' },
                { color: '#00FFFF', text: 'Strong ‚Äì' },
                { color: '#0000FF', text: 'Moderate ‚Äì' },
                { color: '#FFFFFF', text: 'Weak ‚Äì' }
            ];
            const totalWidth = items.reduce((sum, item) => sum + ctx.measureText(item.text).width + 30, 0);
            const startX = w / 2 - totalWidth / 2;
            ctx.font = `${config.fontSize || 11}px Arial`;
            ctx.textAlign = 'left';
            let xOffset = startX;
            for (let i = 0; i < items.length; i++) {
                ctx.fillStyle = items[i].color;
                ctx.beginPath();
                ctx.arc(xOffset + 6, topY + 10, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.fillText(items[i].text, xOffset + 16, topY + 14);
                xOffset += ctx.measureText(items[i].text).width + 22;
            }
        }

        window.onload = init;
    </script>
</body>
</html>

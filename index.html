<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Sigma TA Web</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background-color: #0b0b15;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            background-color: #1a1a2e;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: all 0.3s ease;
        }
        .header.collapsed {
            height: 0 !important;
            min-height: 0 !important;
            padding: 0 10px !important;
            opacity: 0;
            overflow: hidden;
        }
        .menu-row {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }
        .menu-row label {
            font-size: 12px;
            color: #aaa;
            min-width: 65px;
            white-space: nowrap;
        }
        .symbol-btn, .interval-btn {
            background-color: #2d2d44;
            color: #ccc;
            border: 1px solid #444;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            min-height: 28px;
            min-width: 42px;
            justify-content: center;
        }
        .symbol-btn.active, .interval-btn.active {
            background-color: #4a4a6a;
            color: white;
            border-color: #6a6a9a;
        }
        .header input, .header button {
            background-color: #2d2d44;
            color: white;
            border: 1px solid #444;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            min-height: 28px;
        }
        .header button {
            background-color: #4CAF50;
            cursor: pointer;
            font-weight: bold;
            min-width: 60px;
        }
        .chart-title {
            background-color: #161625;
            padding: 8px 15px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .toggle-menu-btn {
            background: #2d2d44;
            border: 1px solid #444;
            color: #ccc;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
        }
        .toggle-menu-btn:hover {
            background: #3a3a5a;
        }
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            width: 100%;
        }
        .chart-container {
            flex: 1;
            position: relative;
            background-color: #0b0b15;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .status-bar {
            background-color: #1a1a2e;
            padding: 4px 10px;
            font-size: 11px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div class="header" id="mainHeader">
        <div class="menu-row">
            <label>Symbol:</label>
            <div class="symbol-btn active" data-symbol="BTCUSDT">â‚¿ BTC</div>
            <div class="symbol-btn" data-symbol="ETHUSDT">Îž ETH</div>
            <div class="symbol-btn" data-symbol="BNBUSDT">ðŸ”¶ BNB</div>
            <div class="symbol-btn" data-symbol="ADAUSDT">ðŸ”· ADA</div>
            <div class="symbol-btn" data-symbol="SOLUSDT">â—Ž SOL</div>
        </div>
        <div class="menu-row">
            <label>Interval:</label>
            <div class="interval-btn" data-interval="1m">1m</div>
            <div class="interval-btn" data-interval="2m">2m</div>
            <div class="interval-btn" data-interval="3m">3m</div>
            <div class="interval-btn" data-interval="5m">5m</div>
            <div class="interval-btn" data-interval="15m">15m</div>
            <div class="interval-btn" data-interval="30m">30m</div>
            <div class="interval-btn" data-interval="1h">1h</div>
            <div class="interval-btn" data-interval="2h">2h</div>
            <div class="interval-btn" data-interval="4h">4h</div>
            <div class="interval-btn" data-interval="6h">6h</div>
            <div class="interval-btn" data-interval="8h">8h</div>
            <div class="interval-btn" data-interval="12h">12h</div>
            <div class="interval-btn active" data-interval="1d">1d</div>
            <div class="interval-btn" data-interval="2d">2d</div>
            <div class="interval-btn" data-interval="3d">3d</div>
            <div class="interval-btn" data-interval="1w">1w</div>
            <div class="interval-btn" data-interval="1M">1M</div>
        </div>
        <div class="menu-row">
            <label>A:</label>
            <input type="number" id="analysisLimit" value="10000" min="500" max="20000" step="500">
            <label>D:</label>
            <input type="number" id="displayLimit" value="500" min="10" max="1000" step="10">
            <label>EMA:</label>
            <input type="number" id="emaPeriod" value="96" min="10" max="500" step="10">
            <label>W:</label>
            <input type="number" id="derivWindow" value="4" min="2" max="20" step="1">
            <label>Upd:</label>
            <input type="number" id="updateInterval" value="5000" min="1000" max="300000" step="1000">
            <button id="applyBtn">Apply</button>
        </div>
    </div>
    <div class="chart-title" id="chartTitle">
        <span id="chartTitleText">â€”</span>
        <div class="toggle-menu-btn" id="toggleMenuBtn">â‰¡</div>
    </div>
    <div class="container">
        <div class="chart-container">
            <canvas id="chartCanvas"></canvas>
        </div>
    </div>
    <div class="status-bar">
        <div id="lastUpdated">Last Updated: --:--:--</div>
        <div>Use Wheel to Zoom</div>
    </div>
    <script>
        const config = {
            symbol: 'BTCUSDT',
            interval: '1d',
            analysisLimit: 10000,
            displayLimit: 500,
            emaPeriod: 96,
            derivWindow: 4,
            updateIntervalMs: 5000,
            markerOffsetPx: 10
        };

        let fullCandleData = [];
        let markers = [];
        let currentPrice = null;
        let lastUpdateTime = null;

        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        const chartTitleText = document.getElementById('chartTitleText');
        const mainHeader = document.getElementById('mainHeader');
        const toggleMenuBtn = document.getElementById('toggleMenuBtn');

        const symbolButtons = document.querySelectorAll('.symbol-btn');
        const intervalButtons = document.querySelectorAll('.interval-btn');
        const analysisLimitInput = document.getElementById('analysisLimit');
        const displayLimitInput = document.getElementById('displayLimit');
        const emaPeriodInput = document.getElementById('emaPeriod');
        const derivWindowInput = document.getElementById('derivWindow');
        const updateIntervalInput = document.getElementById('updateInterval');
        const applyBtn = document.getElementById('applyBtn');
        const lastUpdatedDiv = document.getElementById('lastUpdated');

        let menuCollapsed = false;
        toggleMenuBtn.addEventListener('click', () => {
            menuCollapsed = !menuCollapsed;
            mainHeader.classList.toggle('collapsed', menuCollapsed);
            toggleMenuBtn.textContent = menuCollapsed ? 'â‰¡' : 'Ã—';
            setTimeout(updateDisplay, 150);
        });

        // ... Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¹ ÐºÐ¾Ð´ Ð±ÐµÐ· Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹ Ð´Ð¾ drawAdaptiveTimeGrid ...

        const Database = {
            dbName: 'sigma_candles_v11',
            initDB: () => {
                if (!localStorage.getItem(this.dbName)) {
                    localStorage.setItem(this.dbName, JSON.stringify({}));
                }
            },
            save: (candles, symbol, interval) => {
                try {
                    const db = JSON.parse(localStorage.getItem(this.dbName)) || {};
                    const key = `${symbol}_${interval}`;
                    db[key] = candles.slice(-20000);
                    localStorage.setItem(this.dbName, JSON.stringify(db));
                } catch (e) {
                    console.error("DB save error:", e);
                }
            },
            load: (symbol, interval, limit) => {
                try {
                    const db = JSON.parse(localStorage.getItem(this.dbName)) || {};
                    const key = `${symbol}_${interval}`;
                    return db[key] ? db[key].slice(-limit) : [];
                } catch (e) {
                    console.error("DB load error:", e);
                    return [];
                }
            }
        };

        Database.initDB();

        const SettingsManager = {
            key: 'sigma_ta_settings_v11',
            load: () => {
                try {
                    return JSON.parse(localStorage.getItem(this.key)) || config;
                } catch {
                    return {...config};
                }
            },
            save: () => {
                try {
                    localStorage.setItem(this.key, JSON.stringify(config));
                } catch (e) {
                    console.error("Settings save error:", e);
                }
            }
        };

        function init() {
            loadSettings();
            setupListeners();
            updateButtonStates();
            loadData();
            setInterval(loadData, config.updateIntervalMs);
            window.addEventListener('resize', () => requestAnimationFrame(updateDisplay));
            window.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            updateDisplay();
        }

        function loadSettings() {
            const saved = SettingsManager.load();
            Object.assign(config, saved);
            analysisLimitInput.value = config.analysisLimit;
            displayLimitInput.value = config.displayLimit;
            emaPeriodInput.value = config.emaPeriod;
            derivWindowInput.value = config.derivWindow;
            updateIntervalInput.value = config.updateIntervalMs;
        }

        function setupListeners() {
            symbolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    config.symbol = btn.dataset.symbol;
                    updateButtonStates();
                    applySettings();
                });
            });
            intervalButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    config.interval = btn.dataset.interval;
                    updateButtonStates();
                    applySettings();
                });
            });
            applyBtn.addEventListener('click', applySettings);
            const inputs = [analysisLimitInput, displayLimitInput, emaPeriodInput, derivWindowInput, updateIntervalInput];
            inputs.forEach(el => el.addEventListener('change', applySettings));
        }

        function updateButtonStates() {
            symbolButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.symbol === config.symbol);
            });
            intervalButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.interval === config.interval);
            });
        }

        function applySettings() {
            config.analysisLimit = parseInt(analysisLimitInput.value);
            config.displayLimit = parseInt(displayLimitInput.value);
            config.emaPeriod = parseInt(emaPeriodInput.value);
            config.derivWindow = parseInt(derivWindowInput.value);
            config.updateIntervalMs = parseInt(updateIntervalInput.value);
            SettingsManager.save();
            document.title = `Sigma TA Web - ${config.symbol} (${config.interval})`;
            loadData();
        }

        function adjustDisplayLimit(delta) {
            let newVal = config.displayLimit + delta;
            newVal = Math.max(10, Math.min(1000, newVal));
            if (newVal !== config.displayLimit) {
                config.displayLimit = newVal;
                displayLimitInput.value = newVal;
                updateDisplay();
            }
        }

        function handleKeyDown(e) {
            if (e.key === '+' || e.key === '=' || e.key === 'Add') {
                adjustDisplayLimit(-5);
                e.preventDefault();
            } else if (e.key === '-' || e.key === '_' || e.key === 'Subtract') {
                adjustDisplayLimit(5);
                e.preventDefault();
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 10 : -10;
            adjustDisplayLimit(delta);
        }

        async function loadData() {
            try {
                await loadRealData();
            } catch (err) {
                console.warn("Real data failed:", err.message);
                const cached = Database.load(config.symbol, config.interval, config.analysisLimit);
                if (cached.length > 0) {
                    fullCandleData = cached;
                } else {
                    generateSimulatedData();
                }
                updateStatus();
            }
            analyzeData();
            updateDisplay();
            Database.save(fullCandleData, config.symbol, config.interval);
        }

        async function loadRealData() {
            const url = `https://api.binance.com/api/v3/klines?symbol=${config.symbol}&interval=${config.interval}&limit=${config.analysisLimit}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const raw = await res.json();
            fullCandleData = raw.map(item => ({
                time: item[0],
                open: parseFloat(item[1]),
                high: parseFloat(item[2]),
                low: parseFloat(item[3]),
                close: parseFloat(item[4])
            }));
            updateStatus();
        }

        function generateSimulatedData() {
            const now = Date.now();
            const sec = getIntervalSeconds(config.interval);
            fullCandleData = [];
            let t = now - config.analysisLimit * sec * 1000;
            let price = 40000 + Math.random() * 20000;
            for (let i = 0; i < config.analysisLimit; i++) {
                const vol = 0.02;
                const chg = (Math.random() - 0.5) * vol * 2;
                const open = price;
                const close = open * (1 + chg);
                const high = Math.max(open, close) * (1 + Math.random() * 0.01);
                const low = Math.min(open, close) * (1 - Math.random() * 0.01);
                fullCandleData.push({
                    time: t,
                    open: parseFloat(open.toFixed(2)),
                    high: parseFloat(high.toFixed(2)),
                    low: parseFloat(low.toFixed(2)),
                    close: parseFloat(close.toFixed(2))
                });
                price = close;
                t += sec * 1000;
            }
            updateStatus();
        }

        function updateStatus() {
            currentPrice = fullCandleData[fullCandleData.length - 1].close;
            lastUpdateTime = new Date();
            const up = fullCandleData.length > 1 && currentPrice >= fullCandleData[fullCandleData.length - 2].close;
            const color = up ? '#26a69a' : '#ef5350';
            chartTitleText.innerHTML = `${config.symbol} (${config.interval}) &nbsp; <span style="color:${color}">$${currentPrice.toLocaleString()}</span>`;
            lastUpdatedDiv.textContent = `Last Updated: ${formatTime(lastUpdateTime)}`;
        }

        function getIntervalSeconds(interval) {
            const map = {
                '1m':60, '2m':120, '3m':180, '5m':300, '15m':900, '30m':1800,
                '1h':3600, '2h':7200, '4h':14400, '6h':21600, '8h':28800, '12h':43200,
                '1d':86400, '2d':172800, '3d':259200, '1w':604800, '1M':2592000
            };
            return map[interval] || 3600;
        }

        function formatTime(date) {
            return date.toTimeString().split(' ')[0];
        }

        function analyzeData() {
            if (fullCandleData.length < config.emaPeriod + 20) {
                markers = [];
                return;
            }
            const closes = fullCandleData.map(d => d.close);
            const ema = calculateEMA(closes, config.emaPeriod);
            const deriv = calculateDerivative(ema, config.derivWindow);
            markers = findExtremeMarkers(fullCandleData, ema, deriv);
        }

        function calculateEMA(prices, period) {
            const ema = [prices[0]];
            const alpha = 2 / (period + 1);
            for (let i = 1; i < prices.length; i++) {
                ema[i] = alpha * prices[i] + (1 - alpha) * ema[i-1];
            }
            return ema;
        }

        function calculateDerivative(vals, w) {
            const d = new Array(vals.length).fill(0);
            for (let i = w; i < vals.length; i++) {
                d[i] = vals[i] - vals[i - w];
            }
            return d;
        }

        function findExtremeMarkers(data, ema, deriv) {
            const start = config.emaPeriod + 10;
            const end = deriv.length - 5;
            if (end <= start) return [];
            const slice = deriv.slice(start, end);
            const mean = slice.reduce((a,b) => a + b, 0) / slice.length;
            const variance = slice.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / slice.length;
            const std = Math.sqrt(variance || 1);
            if (std === 0) return [];
            const z = deriv.map(v => (v - mean) / std);
            const res = [];
            for (let i = start; i < end; i++) {
                const zi = z[i];
                if (Math.abs(zi) < 1) continue;
                const d = data[i];
                let color, yPrice, isAbove;
                if (zi > 0) {
                    yPrice = d.high;
                    isAbove = true;
                    color = Math.abs(zi) >= 3 ? '#FF00FF' : Math.abs(zi) >= 2 ? '#FF0000' : '#FFFF00';
                } else {
                    yPrice = d.low;
                    isAbove = false;
                    color = Math.abs(zi) >= 3 ? '#00FFFF' : Math.abs(zi) >= 2 ? '#0000FF' : '#FFFFFF';
                }
                res.push({ time: d.time, price: yPrice, color, isAbove });
            }
            return res;
        }

        function updateDisplay() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            if (width > 0 && height > 0) {
                canvas.width = width;
                canvas.height = height;
                drawChart();
            }
        }

        function drawChart() {
            if (!fullCandleData.length) return;
            const displayData = fullCandleData.slice(-config.displayLimit);
            if (displayData.length === 0) return;

            const visibleTimes = new Set(displayData.map(d => d.time));
            const visibleMarkers = markers.filter(m => visibleTimes.has(m.time));

            const w = canvas.width;
            const h = canvas.height;
            const marginX = Math.max(50, Math.min(70, w * 0.1));
            const marginY = 40;
            const drawH = h - 2 * marginY;

            ctx.fillStyle = '#0b0b15';
            ctx.fillRect(0, 0, w, h);

            const times = displayData.map(d => d.time);
            const lows = displayData.map(d => d.low);
            const highs = displayData.map(d => d.high);
            const tMin = Math.min(...times);
            const tMax = Math.max(...times);
            const pMin = Math.min(...lows);
            const pMax = Math.max(...highs);
            const priceRange = pMax - pMin;
            const padding = priceRange * 0.05;
            const pMinAdj = pMin - padding;
            const pMaxAdj = pMax + padding;
            const priceRangeAdj = pMaxAdj - pMinAdj;
            const timeRange = tMax - tMin;

            drawPriceGrid(pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            if (currentPrice !== null) {
                drawCurrentPriceLine(currentPrice, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            }
            drawAdaptiveTimeGrid(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawCandles(displayData, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawMarkers(visibleMarkers, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH);
            drawLegendLeft(w, h, marginY);
        }

        function drawPriceGrid(pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const rawStep = priceRangeAdj / 6;
            const mag = Math.pow(10, Math.floor(Math.log10(rawStep)));
            const step = mag * Math.round(rawStep / mag) || rawStep;
            const start = step * Math.floor(pMinAdj / step);
            const n = Math.ceil((pMaxAdj - start) / step) + 1;
            for (let i = 0; i < n; i++) {
                const price = start + i * step;
                if (price < pMinAdj || price > pMaxAdj) continue;
                const y = marginY + (pMaxAdj - price) / priceRangeAdj * drawH;
                if (y < marginY || y > h - marginY) continue;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(marginX, y);
                ctx.lineTo(w - marginX, y);
                ctx.stroke();
                ctx.fillStyle = '#AAA';
                ctx.font = '10px Arial';
                ctx.fillText(price.toLocaleString(), w - marginX + (w > 500 ? 10 : 2), y + 4);
            }
        }

        function drawCurrentPriceLine(price, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const y = marginY + (pMaxAdj - price) / priceRangeAdj * drawH;
            if (y < marginY || y > h - marginY) return;
            let color = '#00FFFF';
            if (fullCandleData.length > 1) {
                const prev = fullCandleData[fullCandleData.length - 2].close;
                color = price >= prev ? '#26a69a' : '#ef5350';
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(marginX, y);
            ctx.lineTo(w - marginX, y);
            ctx.stroke();
            ctx.fillStyle = color;
            ctx.font = 'bold 10px Arial';
            ctx.fillText(`$${price.toLocaleString()}`, w - marginX + (w > 500 ? 10 : 2), y - 2);
        }

        // === Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐž: 1d â†’ Ð½ÐµÐ´ÐµÐ»Ð¸ ===
        function drawAdaptiveTimeGrid(data, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const interval = config.interval;
            let majorStepMs = 0;
            let formatLabel = (ts) => '';

            if (['1m', '2m'].includes(interval)) {
                // 1m, 2m â†’ Ð¿Ð¾ Ñ‡Ð°ÑÐ°Ð¼
                majorStepMs = 3600 * 1000;
                formatLabel = (ts) => {
                    const d = new Date(ts);
                    return `${d.getHours()}:00`;
                };
            } else if (['3m', '5m'].includes(interval)) {
                // 3m, 5m â†’ Ð¿Ð¾ Ñ‡Ð°ÑÐ°Ð¼
                majorStepMs = 3600 * 1000;
                formatLabel = (ts) => {
                    const d = new Date(ts);
                    return `${d.getHours()}:00`;
                };
            } else if (['15m', '30m', '1h'].includes(interval)) {
                // 15mâ€“1h â†’ Ð¿Ð¾ ÑÑƒÑ‚ÐºÐ°Ð¼
                majorStepMs = 86400 * 1000;
                formatLabel = (ts) => {
                    const d = new Date(ts);
                    return `${d.getDate()}`;
                };
            } else if (['2h', '4h', '6h', '8h', '12h'].includes(interval)) {
                // 2hâ€“12h â†’ Ð¿Ð¾ ÑÑƒÑ‚ÐºÐ°Ð¼
                majorStepMs = 86400 * 1000;
                formatLabel = (ts) => {
                    const d = new Date(ts);
                    return `${d.getDate()}`;
                };
            } else if (['1d', '2d', '3d'].includes(interval)) {
                // 1d, 2d, 3d â†’ Ð¿Ð¾ Ð½ÐµÐ´ÐµÐ»ÑÐ¼
                majorStepMs = 7 * 86400 * 1000;
                formatLabel = (ts) => {
                    const d = new Date(ts);
                    return `${d.getMonth()+1}/${d.getDate()}`;
                };
            } else if (interval === '1w') {
                // 1w â†’ Ð¿Ð¾ Ð¼ÐµÑÑÑ†Ð°Ð¼
                majorStepMs = 30.44 * 86400 * 1000;
                formatLabel = (ts) => {
                    const d = new Date(ts);
                    return `${d.getMonth()+1}/${String(d.getFullYear()).slice(-2)}`;
                };
            } else if (interval === '1M') {
                // 1M â†’ Ð¿Ð¾ Ð³Ð¾Ð´Ð°Ð¼
                majorStepMs = 365.25 * 86400 * 1000;
                formatLabel = (ts) => {
                    const d = new Date(ts);
                    return `${d.getFullYear()}`;
                };
            } else {
                majorStepMs = 86400 * 1000;
                formatLabel = (ts) => `${new Date(ts).getDate()}`;
            }

            const firstTs = tMin;
            let startMajor = Math.floor(firstTs / majorStepMs) * majorStepMs;

            for (let t = startMajor; t <= tMin + timeRange + majorStepMs; t += majorStepMs) {
                if (t < tMin - majorStepMs || t > tMin + timeRange + majorStepMs) continue;
                const x = marginX + (t - tMin) / timeRange * (w - 2 * marginX);
                if (x < marginX || x > w - marginX) continue;

                ctx.strokeStyle = '#555777';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, marginY);
                ctx.lineTo(x, h - marginY);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#888CCC';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(formatLabel(t), x, h - 12);
            }
        }

        function drawCandles(data, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            const candleWidth = Math.max(1, (w - 2 * marginX) / data.length * 0.8);
            for (const d of data) {
                const x = marginX + (d.time - tMin) / timeRange * (w - 2 * marginX);
                const yOpen = marginY + (pMaxAdj - d.open) / priceRangeAdj * drawH;
                const yClose = marginY + (pMaxAdj - d.close) / priceRangeAdj * drawH;
                const yHigh = marginY + (pMaxAdj - d.high) / priceRangeAdj * drawH;
                const yLow = marginY + (pMaxAdj - d.low) / priceRangeAdj * drawH;
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, yHigh);
                ctx.lineTo(x, yLow);
                ctx.stroke();
                const isUp = d.close >= d.open;
                ctx.strokeStyle = isUp ? '#26a69a' : '#ef5350';
                ctx.lineWidth = Math.max(1.5, candleWidth);
                const yBody = Math.min(yOpen, yClose);
                const hBody = Math.abs(yClose - yOpen);
                if (hBody < 2) {
                    ctx.beginPath();
                    ctx.moveTo(x, yBody - 1);
                    ctx.lineTo(x, yBody + 1);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(x, yBody);
                    ctx.lineTo(x, yBody + hBody);
                    ctx.stroke();
                }
            }
        }

        function drawMarkers(markers, tMin, timeRange, pMinAdj, pMaxAdj, priceRangeAdj, w, h, marginX, marginY, drawH) {
            for (const m of markers) {
                const x = marginX + (m.time - tMin) / timeRange * (w - 2 * marginX);
                const yBase = marginY + (pMaxAdj - m.price) / priceRangeAdj * drawH;
                const y = m.isAbove ? yBase - config.markerOffsetPx : yBase + config.markerOffsetPx;
                ctx.fillStyle = m.color;
                ctx.beginPath();
                ctx.arc(x, y, w > 400 ? 3 : 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawLegendLeft(w, h, topY) {
            if (w < 400) return;
            const items = [
                { color: '#FF00FF', text: 'Strong +' },
                { color: '#FF0000', text: 'Moderate +' },
                { color: '#FFFF00', text: 'Weak +' },
                { color: '#00FFFF', text: 'Strong â€“' },
                { color: '#0000FF', text: 'Moderate â€“' },
                { color: '#FFFFFF', text: 'Weak â€“' }
            ];
            const startX = 10;
            const itemH = 20;
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < items.length; i++) {
                const y = topY + i * itemH;
                ctx.fillStyle = items[i].color;
                ctx.beginPath();
                ctx.arc(startX + 6, y + 6, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.fillText(items[i].text, startX + 16, y + 10);
            }
        }

        window.onload = init;
    </script>
</body>
</html>
